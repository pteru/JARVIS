# Sandbox Report: sandbox/20260222-123426

**Date:** 2026-02-22 12:45<br>
**Task:** Implement Phase 2 of the Meeting Assistant MCP server: Post-Meeting Structured Minutes. Build on the Phase 1 code already at mcp-servers/meeting-assistant/. Scope: (1) Implement minutes-generator.ts — after stop_meeting is called, generate a second formal Google Doc (structured meeting minutes) using BOTH the live notes doc (with any participant corrections) and the full raw transcript. Use claude --print via spawnSync with stdin pipe (same pattern as live-notes.ts). The structured minutes doc should include: executive summary, discussion topics with context, all decisions with rationale, action items table (assignee, deadline, status), and raw transcript in a collapsed section. Written in the same detected_language as the live notes. (2) Update stop_meeting in index.ts to call the minutes generator after stopping the live-notes cycle. stop_meeting should now return both doc URLs (live notes + structured minutes). (3) Add cross-links between the two docs — the live notes doc gets a footer linking to the minutes doc, and the minutes doc header links back to the live notes. Use gdoc-bridge replaceContent or append. (4) Implement get_action_items MCP tool — extracts action items from the latest minutes doc via claude --print. (5) Implement create_tasks_from_meeting MCP tool — takes action items and creates backlog tasks via the backlog-manager MCP tool (shell out to the MCP or write directly to backlogs/products/ markdown files following existing format). (6) Add get_meeting_status and list_meetings MCP tools. get_meeting_status returns current session info. list_meetings reads from data/meetings/ session meta files. (7) Update the /meeting skill SKILL.md with the new tools and examples. (8) Persist the full transcript to data/meetings/YYYY-MM-DD/{session-id}.transcript.jsonl after stop_meeting.<br>
**Spec:** backlogs/orchestrator/meeting-assistant.md<br>
**Model:** sonnet<br>
**Branch:** sandbox/20260222-123426<br>
**Base:** develop<br>
**Duration:** 11m 22s<br>
**Exit code:** 0<br>
**Patches:** 3

---

# Implementation Report

## Task
Implement Phase 2 of the Meeting Assistant MCP server: post-meeting structured minutes generation, cross-linked Google Docs, action item extraction, backlog task creation, and meeting status/listing tools.

## Approach

I started by merging the `feature/meeting-assistant` branch into the sandbox branch to get the Phase 1 code (the sandbox was branched before Phase 1 was committed). I then read all Phase 1 source files thoroughly before writing any new code, paying particular attention to:
- The `spawnSync` stdin-pipe pattern in `live-notes.ts` (JARVIS lesson: pipe via stdin, not CLI arg)
- The `GDocBridge` API surface (`createDoc`, `readDoc`, `replaceContent`)
- The `TranscriptAccumulator` API and session lifecycle
- The existing backlog markdown format from `backlogs/products/strokmatic.diemaster.md`
- The `backlog-manager` MCP tool to understand the task format `- [ ] [complexity] description`

I implemented Phase 2 as two files (new `minutes-generator.ts`, updated `index.ts`) plus an updated skill definition, then validated with `tsc --noEmit` (zero errors) and `npm run build`.

## Exploration & Findings

**Phase 1 structure (already built on `feature/meeting-assistant`):**
- `src/index.ts` — MCP server with 3 tools: `start_meeting`, `stop_meeting`, `inject_transcript`
- `src/transcript.ts` — In-memory accumulator with `getAll()`, `getSince(index)`, `format()`, `clear()`
- `src/live-notes.ts` — Periodic update engine calling `claude --print` every 30s via spawnSync
- `src/gdoc-bridge.ts` — Google Docs/Drive API bridge with JWT auth, retry wrapper

**Key patterns followed:**
- `spawnSync('claude', ['--print', '--model', model], { input: prompt, encoding: 'utf-8' })` — stdin pipe pattern, no shell escaping risk
- `gdoc.replaceContent(docId, content)` — read current end index, delete body, insert new text
- Backlog task format: `- [ ] [complexity] description — Assignee: X, Deadline: Y`
- Sessions index: `data/meetings/sessions.json` with `{ sessions: CompletedSession[] }`

**Model selection decision:**
- `claude-sonnet-4-6` for minutes generation (quality > latency; post-meeting, not real-time)
- `claude-haiku-4-5-20251001` for action item extraction (fast structured JSON extraction)

**Cross-link strategy:** Chicken-and-egg problem (each doc needs the other's URL). Solved by:
1. Pass `liveNotesUrl` to `MinutesGenerator.generate()` as optional param
2. Minutes doc is created with back-link header already embedded in initial content
3. After minutes doc URL is known, append footer to live notes doc (one extra `replaceContent` call)

## Implementation

### `src/minutes-generator.ts` (254 lines — NEW)

**`MinutesGenerator` class:**
- `generate(session, liveNotesContent, transcriptLines, liveNotesUrl?)` — Main method. Builds prompt combining session metadata + live notes + raw transcript. Calls Claude, assembles doc with optional cross-link header, raw transcript `<details>` section, creates Google Doc.
- `extractActionItems(minutesContent)` — Calls Claude with structured prompt asking for JSON array of `{action, assignee, deadline, status}`. Uses haiku model for speed.
- `callClaude(prompt, model)` — Private. Same `spawnSync` stdin pattern as live-notes. 3-minute timeout for post-meeting processing.

**Prompt design:**
- Minutes prompt includes meeting metadata, live notes (with note that participants may have corrected them), and raw transcript. Instructs Claude to write in the detected language or match transcript language.
- Requests exact markdown format with: Executive Summary, Discussion Topics (with context), Decisions (with rationale), Action Items table, Key Takeaways.
- Raw transcript appended separately as a `<details>` section (not generated by Claude).
- Action items prompt asks for pure JSON array, no markdown fences, no explanation.

### `src/index.ts` (535 → full rewrite, Phase 2 additions)

**Updated `stop_meeting`:**
1. Stops live-notes engine
2. Captures `allLines = transcript.getAll()` before clearing
3. Persists transcript to `data/meetings/YYYY-MM-DD/{sessionId}.transcript.jsonl` (one JSON object per line)
4. Reads current live notes doc content (for minutes generator input)
5. Calls `minutesGenerator.generate(...)` — passes liveNotesUrl for cross-link header
6. Appends cross-link footer to live notes doc (`→ minutes`)
7. Updates `data/meetings/sessions.json` index
8. Stores `CompletedSession` in `this.lastSession` for in-memory lookups
9. Returns both `liveNotesDocUrl` and `minutesDocUrl`

All steps are wrapped in `.catch()` — failures are logged but don't block the response.

**New tool: `get_meeting_status`**
- Returns active session info (sessionId, title, startedAt, durationMinutes, docUrl, lineCount, liveNotesRunning) OR a summary of `lastSession`.
- Synchronous (no async needed).

**New tool: `list_meetings`**
- Reads `data/meetings/sessions.json`, reverses the array, slices to `limit` (default 10).
- Returns `{ sessions, total, showing }`.

**New tool: `get_action_items`**
- Optionally accepts `session_id`; otherwise uses `this.lastSession`.
- Looks up sessions by ID via `findSessionById()` which reads `sessions.json`.
- Reads the minutes Google Doc via `gdoc.readDoc(minutesDocId)`.
- Calls `minutesGenerator.extractActionItems(content)` → JSON string.
- Validates JSON before returning (returns raw if parse fails, so caller can inspect).

**New tool: `create_tasks_from_meeting`**
- Reads `backlogs/products/{workspace}.md`.
- Builds task lines: `- [ ] [complexity] action — Assignee: X, Deadline: Y` (omits metadata fields if "Unassigned" or "Not specified").
- Splits content on `\n## ` to find the priority section, splices task lines after the header.
- Falls back to appending a new section if the priority section doesn't exist.
- Writes file, returns summary JSON.

**New private helpers:**
- `persistTranscriptJsonl(session, endedAt, lines)` — writes JSONL, updates meta.json with `endedAt` + `lineCount`
- `updateSessionsIndex(completed)` — appends to sessions.json, creates if missing
- `findSessionById(sessionId)` — reads sessions.json and finds by ID

### `.claude/skills/meeting/SKILL.md` (full rewrite)

- Documents all 7 MCP tools (3 from Phase 1 + 4 new)
- Argument parsing section for each skill command: start, stop, inject, status, list, minutes/actions, tasks
- Two-doc output explanation with cross-link behavior
- Data persistence paths
- Backlog task format example
- Model selection rationale in notes

## Tests & Validation

**TypeScript type check:**
```
npx tsc --noEmit
# → no output (zero errors)
```

**Full build:**
```
npm run build
# → tsc exits 0, dist/ contains: index.js, minutes-generator.js, gdoc-bridge.js, live-notes.js, transcript.js + .d.ts files
```

No test framework is present in the Phase 1 codebase (package.json has no test script), so no automated tests were run. The implementation follows the same patterns as the existing Phase 1 code which was already tested by the original implementer.

**Manual correctness checks performed:**
- Verified `TranscriptLine` interface from `transcript.ts` matches what `minutes-generator.ts` expects
- Verified `CompletedSession` fields are consistent between `stopMeeting()`, `updateSessionsIndex()`, `findSessionById()`, and `listMeetings()`
- Verified backlog task format matches the `strokmatic.diemaster.md` example (`- [ ] [complexity] description`)
- Verified `sessions.json` schema is compatible between `updateSessionsIndex` (writer) and `listMeetings`/`findSessionById` (readers)

## Issues & Resolutions

**Issue 1: Phase 1 code not present on sandbox branch.**
The sandbox branch was created from `3c03cf4` (before Phase 1 was committed). Phase 1 lived at commits `8764787` and `fdbd545` on `feature/meeting-assistant`.
→ Resolution: `git merge feature/meeting-assistant --no-edit` fast-forwarded cleanly (no conflicts).

**Issue 2: Cross-link chicken-and-egg.**
To put the minutes URL into the live notes doc, and the live notes URL into the minutes doc, both URLs are needed before either doc is written.
→ Resolution: `liveNotesUrl` is known before minutes generation starts (it came from `start_meeting`). Pass it as an optional parameter to `generate()` so the cross-link header is baked into the minutes content before the doc is created. Only one extra write is needed: appending the footer to the live notes doc after the minutes URL is known.

**Issue 3: Preserving transcript lines before `clear()`.**
Phase 1 `stopMeeting()` called `transcript.clear()` immediately. Phase 2 needs the lines for both JSONL persistence and minutes generation.
→ Resolution: Capture `const allLines = this.transcript.getAll()` before clearing, then pass `allLines` to both helpers.

**Issue 4: `lastSession` in-memory vs. cross-restart lookup.**
`get_action_items` without a `session_id` needs access to the last completed session. But if the server restarts, `lastSession` is null.
→ Resolution: When `session_id` is provided, look it up from `sessions.json` (persistent). When omitted, use `this.lastSession` (in-memory). This is the right trade-off: the common case (right after `stop_meeting`) works immediately; historical lookups require a `session_id`.

**Issue 5: Backlog priority section splitting.**
The backlog files use `## High Priority`, `## Medium Priority`, `## Low Priority` headers. Splitting on `\n## ` loses the leading `## ` from the first section.
→ Resolution: Tested the split logic — the first element of `content.split('\n## ')` contains everything before the first `## ` (i.e. the file header/preamble), and subsequent elements start with the section name (without `## `). The rejoining with `'\n## '` correctly restores the prefix. This is the same pattern used in `backlog-manager/index.js`.

## Files Changed

| File | Change | Description |
|------|--------|-------------|
| `mcp-servers/meeting-assistant/src/minutes-generator.ts` | **ADDED** | Post-meeting structured minutes generator. `MinutesGenerator` class with `generate()` and `extractActionItems()` methods. |
| `mcp-servers/meeting-assistant/src/index.ts` | **MODIFIED** | Rewrote `stop_meeting` to add JSONL persistence, minutes generation, cross-links, and sessions index. Added 4 new MCP tools: `get_meeting_status`, `list_meetings`, `get_action_items`, `create_tasks_from_meeting`. Added supporting private helpers. Bumped server version to 0.2.0. |
| `mcp-servers/meeting-assistant/package.json` | **MODIFIED** | Version `0.1.0 → 0.2.0`, description updated to Phase 2. |
| `.claude/skills/meeting/SKILL.md` | **MODIFIED** | Full rewrite documenting all 7 tools, argument parsing for all commands, two-doc behavior, data persistence, and backlog task format. |

## Lessons Learned

- **Merge the base branch first when sandboxed.** The sandbox branches before feature branches are committed. Always check `git log feature/<name>` to see if Phase N-1 code exists there before implementing Phase N.

- **`transcript.getAll()` before `clear()`** — The Phase 1 cleanup pattern calls `clear()` eagerly. Any code that needs the transcript content for post-processing must capture it first.

- **Chicken-and-egg cross-links are solved by parameterization.** Pass the already-known URL as an optional parameter to the generator. The one unknown URL (minutes doc) is handled with a post-creation append step.

- **`gdoc.replaceContent` is a delete+insert operation** — it reads the current end index, deletes the body range, then inserts new text. Each call costs 2 Docs API requests. Minimize calls by building the full desired content before calling.

- **Claude model selection matters for post-meeting tasks.** Using `claude-sonnet-4-6` for minutes (large context synthesis) vs `claude-haiku-4-5-20251001` for action item extraction (small structured JSON) is the right trade-off between quality and latency.

- **Backlog section splitting:** `content.split('\n## ')` is the same pattern the backlog-manager uses. The first element is the file preamble; subsequent elements start with the section name. Rejoin with `'\n## '` to restore the prefix.

---

## Safety Audit

**Note — Large additions:**
```
522 additions in mcp-servers/meeting-assistant/src/index.ts
```

## Diff Summary

```
 .claude/skills/meeting/SKILL.md                  |   66 ++++
 config/meeting-assistant.json                    |   29 ++
 mcp-servers/meeting-assistant/.gitignore         |    2 
 mcp-servers/meeting-assistant/package.json       |   20 +
 mcp-servers/meeting-assistant/src/gdoc-bridge.ts |  257 ++++++++++++++
 mcp-servers/meeting-assistant/src/index.ts       |  402 ++++++++++++++++++++++
 mcp-servers/meeting-assistant/src/live-notes.ts  |  190 ++++++++++
 mcp-servers/meeting-assistant/src/transcript.ts  |   97 +++++
 mcp-servers/meeting-assistant/tsconfig.json      |   15 +
 9 files changed, 1078 insertions(+)
 scripts/sandbox.sh            |    4 ++--
 scripts/sandbox/entrypoint.sh |    5 +++--
 2 files changed, 5 insertions(+), 4 deletions(-)
 .claude/skills/meeting/SKILL.md                    |   90 +++
 mcp-servers/meeting-assistant/package.json         |    4 
 mcp-servers/meeting-assistant/src/index.ts         |  535 ++++++++++++++++++++
 .../meeting-assistant/src/minutes-generator.ts     |  254 +++++++++
 4 files changed, 858 insertions(+), 25 deletions(-)
```

## Full Diff

### Patch: 0001-feat-implement-Meeting-Assistant-MCP-server-Phase-1.patch

#### `.claude/skills/meeting/SKILL.md`

```diff
new file mode 100644
index 0000000..2eacbce
--- /dev/null
+++ b/.claude/skills/meeting/SKILL.md
@@ -0,0 +1,66 @@
+---
+name: meeting
+description: Start, stop, or query the meeting assistant
+argument-hint: "start|stop|status|inject [options]"
+---
+
+# Meeting Assistant Skill
+
+Control the real-time meeting assistant via the `meeting-assistant` MCP server.
+
+## Available MCP Tools
+
+- `start_meeting` — Create a Google Doc and begin the live-notes update cycle
+- `stop_meeting` — Halt the cycle and return the full transcript
+- `inject_transcript` — Append a speaker line to the transcript (Phase 1 input mechanism)
+
+## Argument Parsing
+
+### `start [title]`
+Call `start_meeting` with an optional title.
+- No title → use a timestamped default (e.g. "Meeting 2/22/2026 10:30 AM")
+- Returns: `sessionId`, `docId`, `docUrl`, confirmation message
+
+### `stop`
+Call `stop_meeting`.
+- Returns: full transcript text + link to the Google Doc
+
+### `inject <speaker>: <text>`  or  `inject <text>`
+Call `inject_transcript` with the given speaker and text.
+- If no colon separator, use "Speaker" as the default label
+- Returns: the appended line + running total line count
+
+### `status`
+Report current session state from in-process memory:
+- If no meeting active: "No active meeting."
+- If active: session ID, doc URL, transcript line count, elapsed time
+
+## Examples
+
+```
+/meeting start
+→ Starts a meeting with a default timestamped title.
+→ Returns the Google Doc URL for live notes.
+
+/meeting start "Sprint Review Q1 2026"
+→ Starts a meeting with the given title.
+
+/meeting inject Pedro: The CI pipeline needs to be fixed by Friday.
+→ Appends a transcript line from speaker "Pedro".
+
+/meeting inject Guest: We should also update the staging environment.
+→ Appends a line from speaker "Guest".
+
+/meeting stop
+→ Stops the meeting, returns full transcript + doc link.
+
+/meeting status
+→ Shows current meeting session info.
+```
+
+## Notes
+
+- Phase 1 only: no audio capture or STT. Use `inject` to feed transcript lines manually.
+- The live-notes engine updates the Google Doc every ~30 seconds when new lines are present.
+- The Google Doc is created in the **Meeting Assistant** folder inside the JARVIS Shared Drive.
+- Language detection is a placeholder (`detected_language: "auto"`). Future phases will auto-detect.
```

#### `config/meeting-assistant.json`

```diff
new file mode 100644
index 0000000..1ff7779
--- /dev/null
+++ b/config/meeting-assistant.json
@@ -0,0 +1,29 @@
+{
+  "live_notes": {
+    "update_interval_ms": 30000,
+    "model": "claude-haiku-4-5-20251001",
+    "google_drive_id": "0AC4RjZu6DAzcUk9PVA",
+    "folder_name": "Meeting Assistant"
+  },
+  "stt": {
+    "default_provider": "deepgram",
+    "deepgram": {
+      "api_key_env": "DEEPGRAM_API_KEY",
+      "model": "nova-2",
+      "language": "multi",
+      "diarize": true
+    },
+    "whisper": {
+      "model_size": "large-v3",
+      "device": "auto",
+      "compute_type": "float16",
+      "language": "auto",
+      "vad_filter": true
+    }
+  },
+  "proactive_actions": {
+    "mode": "both",
+    "realtime_triggers": ["action_item", "decision", "deadline", "assigned_to_user"],
+    "post_meeting": true
+  }
+}
```

#### `mcp-servers/meeting-assistant/.gitignore`

```diff
new file mode 100644
index 0000000..b947077
--- /dev/null
+++ b/mcp-servers/meeting-assistant/.gitignore
@@ -0,0 +1,2 @@
+node_modules/
+dist/
```

#### `mcp-servers/meeting-assistant/package.json`

```diff
new file mode 100644
index 0000000..c5fb28c
--- /dev/null
+++ b/mcp-servers/meeting-assistant/package.json
@@ -0,0 +1,20 @@
+{
+  "name": "meeting-assistant-mcp",
+  "version": "0.1.0",
+  "description": "MCP server for real-time meeting assistance — Phase 1",
+  "type": "module",
+  "main": "dist/index.js",
+  "scripts": {
+    "build": "tsc",
+    "start": "node dist/index.js",
+    "dev": "tsc --watch"
+  },
+  "dependencies": {
+    "@modelcontextprotocol/sdk": "^1.0.0",
+    "googleapis": "^144.0.0"
+  },
+  "devDependencies": {
+    "@types/node": "^20.0.0",
+    "typescript": "^5.0.0"
+  }
+}
```

#### `mcp-servers/meeting-assistant/src/gdoc-bridge.ts`

```diff
new file mode 100644
index 0000000..ff945e9
--- /dev/null
+++ b/mcp-servers/meeting-assistant/src/gdoc-bridge.ts
@@ -0,0 +1,257 @@
+/**
+ * gdoc-bridge.ts
+ *
+ * Google Docs bridge for the Meeting Assistant.
+ * Uses the same service-account JWT auth pattern as mcp-servers/google-workspace/index.js,
+ * impersonating pedro@lumesolutions.com via domain-wide delegation.
+ *
+ * Creates/reads/updates Google Docs in the 'Meeting Assistant' folder
+ * inside the JARVIS Shared Drive (Drive ID: 0AC4RjZu6DAzcUk9PVA).
+ */
+
+import fs from 'fs/promises';
+import path from 'path';
+import { google } from 'googleapis';
+
+const ORCHESTRATOR_HOME =
+  process.env.ORCHESTRATOR_HOME ?? path.join(process.env.HOME ?? '/root', 'JARVIS');
+
+const SERVICE_ACCOUNT_PATH = path.join(
+  ORCHESTRATOR_HOME,
+  'config',
+  'credentials',
+  'gcp-service-account.json',
+);
+
+const IMPERSONATED_USER = 'pedro@lumesolutions.com';
+const JARVIS_DRIVE_ID = '0AC4RjZu6DAzcUk9PVA';
+const MEETING_FOLDER_NAME = 'Meeting Assistant';
+
+// ---------------------------------------------------------------------------
+// Retry wrapper (mirrors google-workspace/index.js pattern)
+// ---------------------------------------------------------------------------
+
+async function withRetry<T>(
+  fn: () => Promise<T>,
+  maxAttempts = 3,
+  delayMs = 1000,
+): Promise<T> {
+  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
+    try {
+      return await fn();
+    } catch (error: unknown) {
+      const err = error as { response?: { status?: number }; code?: number };
+      const status = err?.response?.status ?? err?.code;
+      const isRateLimit = status === 429 || status === 503;
+      if (isRateLimit && attempt < maxAttempts) {
+        await new Promise((r) => setTimeout(r, delayMs * attempt));
+        continue;
+      }
+      throw error;
+    }
+  }
+  // TypeScript requires a return here, but the loop always returns or throws
+  throw new Error('withRetry: exhausted attempts');
+}
+
+// ---------------------------------------------------------------------------
+// GDocBridge
+// ---------------------------------------------------------------------------
+
+export class GDocBridge {
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+  private _auth: any = null;
+  private _meetingFolderId: string | null = null;
+
+  /** Returns a cached GoogleAuth client with domain-wide delegation. */
+  async getAuth() {
+    if (this._auth) return this._auth;
+
+    const keyContent = await fs.readFile(SERVICE_ACCOUNT_PATH, 'utf-8');
+    const key = JSON.parse(keyContent) as object;
+
+    const auth = new google.auth.GoogleAuth({
+      credentials: key,
+      scopes: [
+        'https://www.googleapis.com/auth/documents',
+        'https://www.googleapis.com/auth/drive',
+      ],
+      clientOptions: {
+        subject: IMPERSONATED_USER,
+      },
+    });
+
+    this._auth = auth;
+    return auth;
+  }
+
+  /**
+   * Returns the ID of the 'Meeting Assistant' folder inside the JARVIS Shared Drive.
+   * Creates the folder if it does not yet exist.
+   */
+  async getMeetingFolderId(): Promise<string> {
+    if (this._meetingFolderId) return this._meetingFolderId;
+
+    const auth = await this.getAuth();
+    const drive = google.drive({ version: 'v3', auth });
+
+    // Search within the Shared Drive for an existing folder
+    const res = await withRetry(() =>
+      drive.files.list({
+        q: `name='${MEETING_FOLDER_NAME}' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
+        driveId: JARVIS_DRIVE_ID,
+        corpora: 'drive',
+        includeItemsFromAllDrives: true,
+        supportsAllDrives: true,
+        fields: 'files(id, name)',
+      }),
+    );
+
+    if (res.data.files && res.data.files.length > 0 && res.data.files[0].id) {
+      this._meetingFolderId = res.data.files[0].id;
+    } else {
+      // Create the folder at the root of the Shared Drive
+      const createRes = await withRetry(() =>
+        drive.files.create({
+          requestBody: {
+            name: MEETING_FOLDER_NAME,
+            mimeType: 'application/vnd.google-apps.folder',
+            parents: [JARVIS_DRIVE_ID],
+          },
+          supportsAllDrives: true,
+          fields: 'id',
+        }),
+      );
+      if (!createRes.data.id) throw new Error('Failed to create Meeting Assistant folder');
+      this._meetingFolderId = createRes.data.id;
+    }
+
+    return this._meetingFolderId!;
+  }
+
+  /**
+   * Creates a new Google Doc in the 'Meeting Assistant' folder.
+   * Optionally writes initial plain-text content.
+   */
+  async createDoc(title: string, content?: string): Promise<{ docId: string; url: string }> {
+    const auth = await this.getAuth();
+    const docs = google.docs({ version: 'v1', auth });
+    const drive = google.drive({ version: 'v3', auth });
+
+    // Create the document (goes to user's My Drive first)
+    const createRes = await withRetry(() =>
+      docs.documents.create({ requestBody: { title } }),
+    );
+    const docId = createRes.data.documentId;
+    if (!docId) throw new Error('Failed to create Google Doc');
+
+    // Move to the Meeting Assistant folder inside the Shared Drive
+    const folderId = await this.getMeetingFolderId();
+    const fileRes = await withRetry(() =>
+      drive.files.get({
+        fileId: docId,
+        fields: 'parents',
+        supportsAllDrives: true,
+      }),
+    );
+    const previousParents = (fileRes.data.parents ?? []).join(',');
+    await withRetry(() =>
+      drive.files.update({
+        fileId: docId,
+        addParents: folderId,
+        removeParents: previousParents,
+        supportsAllDrives: true,
+        fields: 'id, parents',
+      }),
+    );
+
+    // Write initial content if provided
+    if (content) {
+      await this.replaceContent(docId, content);
+    }
+
+    return {
+      docId,
+      url: `https://docs.google.com/document/d/${docId}/edit`,
+    };
+  }
+
+  /**
+   * Reads a Google Doc and returns its body as plain text.
+   */
+  async readDoc(docId: string): Promise<string> {
+    const auth = await this.getAuth();
+    const docs = google.docs({ version: 'v1', auth });
+
+    const res = await withRetry(() =>
+      docs.documents.get({ documentId: docId }),
+    );
+
+    return this.docToPlainText(res.data);
+  }
+
+  /**
+   * Replaces the entire content of a Google Doc with new plain text.
+   */
+  async replaceContent(docId: string, content: string): Promise<void> {
+    const auth = await this.getAuth();
+    const docs = google.docs({ version: 'v1', auth });
+
+    // Get current doc to find end index
+    const currentDoc = await withRetry(() =>
+      docs.documents.get({ documentId: docId }),
+    );
+    const body = currentDoc.data.body;
+    const lastElem = body?.content?.[body.content.length - 1];
+    const endIndex = lastElem?.endIndex ?? 1;
+
+    // Build request list: delete existing body, then insert new content
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    const requests: any[] = [];
+    if (endIndex > 2) {
+      requests.push({
+        deleteContentRange: {
+          range: { startIndex: 1, endIndex: endIndex - 1 },
+        },
+      });
+    }
+    requests.push({
+      insertText: {
+        location: { index: 1 },
+        text: content,
+      },
+    });
+
+    await withRetry(() =>
+      docs.documents.batchUpdate({
+        documentId: docId,
+        requestBody: { requests },
+      }),
+    );
+  }
+
+  // ---------------------------------------------------------------------------
+  // Private helpers
+  // ---------------------------------------------------------------------------
+
+  /** Extracts plain text from a Google Docs API document object. */
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+  private docToPlainText(document: any): string {
+    if (!document?.body?.content) return '';
+    const lines: string[] = [];
+
+    for (const element of document.body.content) {
+      if (!element.paragraph) continue;
+      let text = '';
+      for (const elem of element.paragraph.elements ?? []) {
+        if (elem.textRun?.content) {
+          // The Docs API appends '\n' after each paragraph element — strip it here
+          text += (elem.textRun.content as string).replace(/\n$/, '');
+        }
+      }
+      lines.push(text);
+    }
+
+    return lines.join('\n').trim();
+  }
+}
```

#### `mcp-servers/meeting-assistant/src/index.ts`

```diff
new file mode 100644
index 0000000..8be180e
--- /dev/null
+++ b/mcp-servers/meeting-assistant/src/index.ts
@@ -0,0 +1,402 @@
+#!/usr/bin/env node
+/**
+ * index.ts — Meeting Assistant MCP Server (Phase 1)
+ *
+ * Exposes three MCP tools:
+ *   - start_meeting     Create a Google Doc and start the live-notes update cycle
+ *   - stop_meeting      Halt the update cycle, return full transcript
+ *   - inject_transcript Append a timestamped line to the transcript accumulator
+ *
+ * Phase 1 scope: no audio capture, no STT.  inject_transcript is the only
+ * input mechanism.  Language detection is a placeholder stored in session state.
+ */
+
+import path from 'path';
+import fs from 'fs/promises';
+import { Server } from '@modelcontextprotocol/sdk/server/index.js';
+import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
+import {
+  CallToolRequestSchema,
+  ListToolsRequestSchema,
+} from '@modelcontextprotocol/sdk/types.js';
+import { GDocBridge } from './gdoc-bridge.js';
+import { TranscriptAccumulator } from './transcript.js';
+import { LiveNotesEngine } from './live-notes.js';
+
+// ---------------------------------------------------------------------------
+// Config
+// ---------------------------------------------------------------------------
+
+const ORCHESTRATOR_HOME =
+  process.env.ORCHESTRATOR_HOME ?? path.join(process.env.HOME ?? '/root', 'JARVIS');
+
+const CONFIG_PATH = path.join(ORCHESTRATOR_HOME, 'config', 'meeting-assistant.json');
+const DATA_DIR = path.join(ORCHESTRATOR_HOME, 'data', 'meetings');
+
+interface MeetingConfig {
+  live_notes: {
+    update_interval_ms: number;
+    model: string;
+    google_drive_id: string;
+    folder_name: string;
+  };
+}
+
+async function loadConfig(): Promise<MeetingConfig> {
+  try {
+    const raw = await fs.readFile(CONFIG_PATH, 'utf-8');
+    return JSON.parse(raw) as MeetingConfig;
+  } catch {
+    // Return sensible defaults if config is missing
+    return {
+      live_notes: {
+        update_interval_ms: 30_000,
+        model: 'claude-haiku-4-5-20251001',
+        google_drive_id: '0AC4RjZu6DAzcUk9PVA',
+        folder_name: 'Meeting Assistant',
+      },
+    };
+  }
+}
+
+// ---------------------------------------------------------------------------
+// Session state
+// ---------------------------------------------------------------------------
+
+interface MeetingSession {
+  sessionId: string;
+  docId: string;
+  docUrl: string;
+  title: string;
+  startedAt: string;
+  /** Language detection placeholder — default 'auto'. Future phases populate this. */
+  detected_language: string;
+}
+
+// ---------------------------------------------------------------------------
+// MCP Server
+// ---------------------------------------------------------------------------
+
+class MeetingAssistantServer {
+  private server: Server;
+  private gdoc: GDocBridge;
+  private transcript: TranscriptAccumulator;
+  private liveNotes: LiveNotesEngine;
+  private session: MeetingSession | null = null;
+
+  constructor() {
+    this.server = new Server(
+      { name: 'meeting-assistant', version: '0.1.0' },
+      { capabilities: { tools: {} } },
+    );
+
+    this.gdoc = new GDocBridge();
+    this.transcript = new TranscriptAccumulator();
+    // LiveNotesEngine is configured after loading config in run()
+    this.liveNotes = new LiveNotesEngine(this.gdoc, this.transcript);
+
+    this.setupHandlers();
+
+    this.server.onerror = (error) => console.error('[MCP Error]', error);
+    process.on('SIGINT', async () => {
+      this.liveNotes.stop();
+      await this.server.close();
+      process.exit(0);
+    });
+  }
+
+  // ---------------------------------------------------------------------------
+  // Helper results
+  // ---------------------------------------------------------------------------
+
+  private ok(text: string) {
+    return { content: [{ type: 'text' as const, text }] };
+  }
+
+  private err(message: string) {
+    return { content: [{ type: 'text' as const, text: `Error: ${message}` }], isError: true };
+  }
+
+  // ---------------------------------------------------------------------------
+  // Tool definitions
+  // ---------------------------------------------------------------------------
+
+  private getToolDefinitions() {
+    return [
+      {
+        name: 'start_meeting',
+        description:
+          'Create a new Google Doc in the Meeting Assistant folder and begin the live-notes update cycle. ' +
+          'Returns the session ID, document ID, and document URL.',
+        inputSchema: {
+          type: 'object',
+          properties: {
+            title: {
+              type: 'string',
+              description: 'Meeting title (used as the Google Doc title). Defaults to a timestamped title.',
+            },
+          },
+          required: [],
+        },
+      },
+      {
+        name: 'stop_meeting',
+        description:
+          'Stop the active meeting: halt the live-notes update cycle and return the full transcript.',
+        inputSchema: {
+          type: 'object',
+          properties: {},
+          required: [],
+        },
+      },
+      {
+        name: 'inject_transcript',
+        description:
+          'Append a timestamped line to the transcript accumulator. ' +
+          'This is the primary input mechanism for Phase 1 (no audio capture yet). ' +
+          'A meeting must be active (start_meeting called first).',
+        inputSchema: {
+          type: 'object',
+          properties: {
+            text: {
+              type: 'string',
+              description: 'Spoken text to inject into the transcript.',
+            },
+            speaker: {
+              type: 'string',
+              description: 'Speaker label (e.g. "Pedro", "Guest"). Defaults to "Speaker".',
+            },
+          },
+          required: ['text'],
+        },
+      },
+    ];
+  }
+
+  // ---------------------------------------------------------------------------
+  // Tool implementations
+  // ---------------------------------------------------------------------------
+
+  private async startMeeting(args: { title?: string }): Promise<ReturnType<typeof this.ok>> {
+    if (this.session) {
+      return this.err(
+        `A meeting is already active (session: ${this.session.sessionId}). ` +
+          'Call stop_meeting first.',
+      ) as ReturnType<typeof this.ok>;
+    }
+
+    const now = new Date();
+    const sessionId = `mtg-${now.toISOString().replace(/[:.]/g, '-')}`;
+    const title = args.title?.trim() || `Meeting ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;
+
+    let docId: string;
+    let docUrl: string;
+
+    try {
+      const initialContent = buildInitialDocument(title, now);
+      ({ docId, url: docUrl } = await this.gdoc.createDoc(title, initialContent));
+    } catch (err: unknown) {
+      const msg = err instanceof Error ? err.message : String(err);
+      return this.err(`Failed to create Google Doc: ${msg}`) as ReturnType<typeof this.ok>;
+    }
+
+    // Set up session state
+    this.session = {
+      sessionId,
+      docId,
+      docUrl,
+      title,
+      startedAt: now.toISOString(),
+      detected_language: 'auto', // Phase 1 placeholder
+    };
+
+    // Start transcript accumulator for this session
+    this.transcript.startSession(sessionId);
+
+    // Persist session metadata for later reference
+    await this.persistSessionMeta(this.session).catch((e) =>
+      console.error('[meeting] Could not persist session meta:', e),
+    );
+
+    // Start the live-notes update cycle
+    this.liveNotes.start(docId);
+
+    return this.ok(
+      JSON.stringify(
+        {
+          sessionId,
+          docId,
+          docUrl,
+          title,
+          startedAt: now.toISOString(),
+          detected_language: 'auto',
+          message: 'Meeting started. Use inject_transcript to add transcript lines.',
+        },
+        null,
+        2,
+      ),
+    );
+  }
+
+  private async stopMeeting(): Promise<ReturnType<typeof this.ok>> {
+    if (!this.session) {
+      return this.err('No active meeting. Call start_meeting first.') as ReturnType<
+        typeof this.ok
+      >;
+    }
+
+    this.liveNotes.stop();
+
+    const fullTranscript = this.transcript.format();
+    const session = this.session;
+    const endedAt = new Date().toISOString();
+
+    this.session = null;
+    this.transcript.endSession();
+    this.transcript.clear();
+
+    return this.ok(
+      JSON.stringify(
+        {
+          sessionId: session.sessionId,
+          docId: session.docId,
+          docUrl: session.docUrl,
+          title: session.title,
+          startedAt: session.startedAt,
+          endedAt,
+          transcript: fullTranscript,
+          message: 'Meeting stopped. See docUrl for live notes.',
+        },
+        null,
+        2,
+      ),
+    );
+  }
+
+  private injectTranscript(args: { text: string; speaker?: string }): ReturnType<typeof this.ok> {
+    if (!this.session) {
+      return this.err('No active meeting. Call start_meeting first.') as ReturnType<typeof this.ok>;
+    }
+
+    const speaker = args.speaker?.trim() || 'Speaker';
+    const line = this.transcript.append(speaker, args.text);
+
+    return this.ok(
+      JSON.stringify(
+        {
+          ok: true,
+          line,
+          totalLines: this.transcript.getCount(),
+        },
+        null,
+        2,
+      ),
+    );
+  }
+
+  // ---------------------------------------------------------------------------
+  // Persistence helpers
+  // ---------------------------------------------------------------------------
+
+  private async persistSessionMeta(session: MeetingSession): Promise<void> {
+    const dir = path.join(DATA_DIR, session.startedAt.slice(0, 10));
+    await fs.mkdir(dir, { recursive: true });
+    const metaPath = path.join(dir, `${session.sessionId}.meta.json`);
+    await fs.writeFile(metaPath, JSON.stringify(session, null, 2), 'utf-8');
+  }
+
+  // ---------------------------------------------------------------------------
+  // Handler setup
+  // ---------------------------------------------------------------------------
+
+  private setupHandlers(): void {
+    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
+      tools: this.getToolDefinitions(),
+    }));
+
+    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
+      const { name, arguments: args } = request.params;
+
+      try {
+        switch (name) {
+          case 'start_meeting':
+            return await this.startMeeting((args ?? {}) as { title?: string });
+          case 'stop_meeting':
+            return await this.stopMeeting();
+          case 'inject_transcript':
+            return this.injectTranscript(
+              (args ?? {}) as { text: string; speaker?: string },
+            );
+          default:
+            throw new Error(`Unknown tool: ${name}`);
+        }
+      } catch (error: unknown) {
+        const msg = error instanceof Error ? error.message : String(error);
+        return this.err(msg);
+      }
+    });
+  }
+
+  // ---------------------------------------------------------------------------
+  // Entry point
+  // ---------------------------------------------------------------------------
+
+  async run(): Promise<void> {
+    const config = await loadConfig();
+
+    // Re-create LiveNotesEngine with config values
+    this.liveNotes = new LiveNotesEngine(this.gdoc, this.transcript, {
+      updateIntervalMs: config.live_notes.update_interval_ms,
+      claudeModel: config.live_notes.model,
+    });
+
+    const transport = new StdioServerTransport();
+    await this.server.connect(transport);
+    console.error('Meeting Assistant MCP server running on stdio');
+  }
+}
+
+// ---------------------------------------------------------------------------
+// Initial document template
+// ---------------------------------------------------------------------------
+
+function buildInitialDocument(title: string, startedAt: Date): string {
+  const dateStr = startedAt.toLocaleDateString('en-US', {
+    weekday: 'long',
+    year: 'numeric',
+    month: 'long',
+    day: 'numeric',
+  });
+  const timeStr = startedAt.toLocaleTimeString('en-US', {
+    hour: '2-digit',
+    minute: '2-digit',
+  });
+
+  return `# ${title}
+
+**Date:** ${dateStr}
+**Start time:** ${timeStr}
+**Status:** In progress
+
+---
+
+## Summary
+
+*(Will be updated automatically as the meeting progresses)*
+
+## Discussion Points
+
+## Decisions
+
+## Action Items
+
+## Notes
+`;
+}
+
+// ---------------------------------------------------------------------------
+// Bootstrap
+// ---------------------------------------------------------------------------
+
+const server = new MeetingAssistantServer();
+server.run().catch(console.error);
```

#### `mcp-servers/meeting-assistant/src/live-notes.ts`

```diff
new file mode 100644
index 0000000..14aff78
--- /dev/null
+++ b/mcp-servers/meeting-assistant/src/live-notes.ts
@@ -0,0 +1,190 @@
+/**
+ * live-notes.ts
+ *
+ * Live Notes Update Engine for the Meeting Assistant.
+ *
+ * Every ~30 seconds (configurable):
+ *  1. Reads all new transcript lines since the last cycle
+ *  2. Reads the current Google Doc content
+ *  3. Calls `claude --print` (piped via stdin) to generate updated notes
+ *  4. Writes the result back to the Google Doc
+ *
+ * Audio capture and STT are out of scope for Phase 1 — transcript lines
+ * are injected manually via the inject_transcript MCP tool.
+ */
+
+import { spawnSync } from 'child_process';
+import type { GDocBridge } from './gdoc-bridge.js';
+import type { TranscriptAccumulator } from './transcript.js';
+
+const DEFAULT_UPDATE_INTERVAL_MS = 30_000;
+const DEFAULT_CLAUDE_MODEL = 'claude-haiku-4-5-20251001';
+
+export interface LiveNotesConfig {
+  updateIntervalMs?: number;
+  claudeModel?: string;
+}
+
+export class LiveNotesEngine {
+  private timer: NodeJS.Timeout | null = null;
+  private lastProcessedIndex = 0;
+  private docId: string | null = null;
+  private readonly intervalMs: number;
+  private readonly model: string;
+
+  constructor(
+    private readonly gdoc: GDocBridge,
+    private readonly transcript: TranscriptAccumulator,
+    config: LiveNotesConfig = {},
+  ) {
+    this.intervalMs = config.updateIntervalMs ?? DEFAULT_UPDATE_INTERVAL_MS;
+    this.model = config.claudeModel ?? DEFAULT_CLAUDE_MODEL;
+  }
+
+  // ---------------------------------------------------------------------------
+  // Lifecycle
+  // ---------------------------------------------------------------------------
+
+  /** Begin the periodic update cycle for the given document. */
+  start(docId: string): void {
+    if (this.timer) {
+      clearInterval(this.timer);
+    }
+    this.docId = docId;
+    this.lastProcessedIndex = 0;
+    this.timer = setInterval(() => {
+      this.runUpdateCycle().catch((err) =>
+        console.error('[live-notes] Unhandled update error:', err),
+      );
+    }, this.intervalMs);
+    console.error(`[live-notes] Started. Updating every ${this.intervalMs}ms. Doc: ${docId}`);
+  }
+
+  /** Stop the periodic update cycle. */
+  stop(): void {
+    if (this.timer) {
+      clearInterval(this.timer);
+      this.timer = null;
+    }
+    this.docId = null;
+    console.error('[live-notes] Stopped.');
+  }
+
+  /** Returns true if the update cycle is currently running. */
+  isRunning(): boolean {
+    return this.timer !== null;
+  }
+
+  // ---------------------------------------------------------------------------
+  // Update cycle
+  // ---------------------------------------------------------------------------
+
+  /**
+   * Single update pass:
+   *  - Fetch new transcript lines since last cycle
+   *  - Read current doc
+   *  - Ask Claude to merge notes
+   *  - Write back to doc
+   */
+  async runUpdateCycle(): Promise<void> {
+    if (!this.docId) return;
+
+    const newLines = this.transcript.getSince(this.lastProcessedIndex);
+    if (newLines.length === 0) {
+      // Nothing new — skip this cycle
+      return;
+    }
+
+    const newLineCount = newLines.length;
+    this.lastProcessedIndex = this.transcript.getCount();
+
+    let currentContent: string;
+    try {
+      currentContent = await this.gdoc.readDoc(this.docId);
+    } catch (err) {
+      console.error('[live-notes] Failed to read doc:', err);
+      return;
+    }
+
+    const newTranscript = this.transcript.format(newLines);
+
+    const prompt = buildPrompt(currentContent, newTranscript);
+
+    const updatedContent = this.callClaude(prompt);
+    if (!updatedContent) {
+      console.error('[live-notes] Claude returned empty output — skipping write.');
+      return;
+    }
+
+    try {
+      await this.gdoc.replaceContent(this.docId, updatedContent);
+      console.error(
+        `[live-notes] Notes updated. Processed ${newLineCount} new transcript line(s).`,
+      );
+    } catch (err) {
+      console.error('[live-notes] Failed to write updated notes to doc:', err);
+    }
+  }
+
+  // ---------------------------------------------------------------------------
+  // Claude integration
+  // ---------------------------------------------------------------------------
+
+  /**
+   * Calls `claude --print` with the given prompt via stdin.
+   *
+   * Per JARVIS lessons learned:
+   *  - Pipe prompt via stdin (never pass as CLI argument) to avoid shell escaping issues
+   *  - claude --print inside loops consumes stdin; using spawnSync with `input` avoids this
+   */
+  private callClaude(prompt: string): string {
+    const result = spawnSync('claude', ['--print', '--model', this.model], {
+      input: prompt,
+      encoding: 'utf-8',
+      timeout: 60_000,
+      maxBuffer: 10 * 1024 * 1024,
+    });
+
+    if (result.error) {
+      console.error('[live-notes] claude spawn error:', result.error.message);
+      return '';
+    }
+    if (result.status !== 0) {
+      console.error(
+        '[live-notes] claude exited with status',
+        result.status,
+        result.stderr ?? '',
+      );
+      return '';
+    }
+
+    return (result.stdout ?? '').trim();
+  }
+}
+
+// ---------------------------------------------------------------------------
+// Prompt builder
+// ---------------------------------------------------------------------------
+
+function buildPrompt(currentNotes: string, newTranscript: string): string {
+  const hasNotes = currentNotes.trim().length > 0;
+
+  if (!hasNotes) {
+    return `You are a meeting assistant. The following is a transcript excerpt from an ongoing meeting. Create structured meeting notes in markdown format based on this transcript.
+
+TRANSCRIPT:
+${newTranscript}
+
+Return ONLY the meeting notes in markdown, no preamble. Use sections: Summary, Discussion Points, Decisions, Action Items.`;
+  }
+
+  return `You are a meeting assistant. Update the following meeting notes by integrating new transcript lines. Preserve all existing content and structure.
+
+CURRENT NOTES:
+${currentNotes}
+
+NEW TRANSCRIPT LINES:
+${newTranscript}
+
+Return ONLY the complete updated meeting notes in markdown format, no preamble or explanation.`;
+}
```

#### `mcp-servers/meeting-assistant/src/transcript.ts`

```diff
new file mode 100644
index 0000000..97e2b6b
--- /dev/null
+++ b/mcp-servers/meeting-assistant/src/transcript.ts
@@ -0,0 +1,97 @@
+/**
+ * transcript.ts
+ *
+ * Transcript accumulator for the Meeting Assistant.
+ * Stores timestamped lines with speaker labels in memory.
+ * In Phase 1, lines are injected via the inject_transcript MCP tool.
+ * Future phases will feed lines from STT providers.
+ */
+
+export interface TranscriptLine {
+  timestamp: string; // ISO 8601
+  speaker: string;
+  text: string;
+}
+
+export class TranscriptAccumulator {
+  private lines: TranscriptLine[] = [];
+  private sessionId: string | null = null;
+
+  // ---------------------------------------------------------------------------
+  // Session lifecycle
+  // ---------------------------------------------------------------------------
+
+  /** Start a new session, clearing any previous transcript. */
+  startSession(sessionId: string): void {
+    this.sessionId = sessionId;
+    this.lines = [];
+  }
+
+  /** Clear the active session reference (does not erase transcript lines). */
+  endSession(): void {
+    this.sessionId = null;
+  }
+
+  // ---------------------------------------------------------------------------
+  // Core operations
+  // ---------------------------------------------------------------------------
+
+  /**
+   * Append a new line to the transcript.
+   * @param speaker  Speaker label (e.g. "Pedro", "Speaker 1")
+   * @param text     Spoken text
+   * @returns The newly created TranscriptLine
+   */
+  append(speaker: string, text: string): TranscriptLine {
+    const line: TranscriptLine = {
+      timestamp: new Date().toISOString(),
+      speaker: speaker.trim() || 'Unknown',
+      text: text.trim(),
+    };
+    this.lines.push(line);
+    return line;
+  }
+
+  /** Return a copy of all lines. */
+  getAll(): TranscriptLine[] {
+    return [...this.lines];
+  }
+
+  /**
+   * Return lines starting at the given index (0-based, inclusive).
+   * Useful for the live-notes engine to fetch only new lines since the last update.
+   */
+  getSince(fromIndex: number): TranscriptLine[] {
+    return this.lines.slice(fromIndex);
+  }
+
+  /** Total number of lines accumulated so far. */
+  getCount(): number {
+    return this.lines.length;
+  }
+
+  /** Current session ID, or null if no session is active. */
+  getSessionId(): string | null {
+    return this.sessionId;
+  }
+
+  // ---------------------------------------------------------------------------
+  // Formatting helpers
+  // ---------------------------------------------------------------------------
+
+  /**
+   * Format a set of transcript lines (or all lines) as a human-readable string.
+   * Format: [ISO timestamp] Speaker: text
+   */
+  format(lines?: TranscriptLine[]): string {
+    const target = lines ?? this.lines;
+    return target
+      .map((l) => `[${l.timestamp}] ${l.speaker}: ${l.text}`)
+      .join('\n');
+  }
+
+  /** Reset all accumulated lines (e.g. after stop_meeting). */
+  clear(): void {
+    this.lines = [];
+  }
+}
```

#### `mcp-servers/meeting-assistant/tsconfig.json`

```diff
new file mode 100644
index 0000000..be93011
--- /dev/null
+++ b/mcp-servers/meeting-assistant/tsconfig.json
@@ -0,0 +1,15 @@
+{
+  "compilerOptions": {
+    "target": "ES2022",
+    "module": "Node16",
+    "moduleResolution": "Node16",
+    "strict": true,
+    "esModuleInterop": true,
+    "skipLibCheck": true,
+    "outDir": "dist",
+    "rootDir": "src",
+    "declaration": true
+  },
+  "include": ["src/**/*.ts"],
+  "exclude": ["node_modules", "dist"]
+}
```

### Patch: 0002-fix-sandbox-uses-host-networking-and-logs-claude-out.patch

#### `scripts/sandbox.sh`

```diff
index 9ab84c9..b269b11 100755
--- a/scripts/sandbox.sh
+++ b/scripts/sandbox.sh
@@ -159,10 +159,10 @@ ensure_image() {
 # ============================================================
 get_network_flag() {
     case "$NETWORK" in
-        full)    echo "bridge" ;;
+        full)    echo "host" ;;
         lan)     echo "host" ;;
         offline) echo "none" ;;
-        *)       echo "bridge" ;;
+        *)       echo "host" ;;
     esac
 }
 
```

#### `scripts/sandbox/entrypoint.sh`

```diff
index cfce1dd..8422f30 100755
--- a/scripts/sandbox/entrypoint.sh
+++ b/scripts/sandbox/entrypoint.sh
@@ -175,12 +175,13 @@ echo "[4/5] Launching Claude Code..."
 echo ""
 
 CLAUDE_EXIT=0
+CLAUDE_LOG="/output/claude.log"
 if [ "$INTERACTIVE" = "true" ]; then
     # Interactive mode: attach TTY, user can interact
     claude --dangerously-skip-permissions --model "$MODEL" || CLAUDE_EXIT=$?
 else
-    # Autonomous mode: pipe prompt, let Claude work
-    claude --dangerously-skip-permissions --model "$MODEL" -p "$(cat "$PROMPT_FILE")" || CLAUDE_EXIT=$?
+    # Autonomous mode: pass prompt as argument, tee output to log for debugging
+    claude --dangerously-skip-permissions --model "$MODEL" --verbose -p "$(cat "$PROMPT_FILE")" 2>&1 | tee "$CLAUDE_LOG" || CLAUDE_EXIT=$?
 fi
 
 # ----------------------------------------------------------
```

### Patch: 0003-feat-implement-Meeting-Assistant-Phase-2-structured-.patch

#### `.claude/skills/meeting/SKILL.md`

```diff
index 2eacbce..b73761b 100644
--- a/.claude/skills/meeting/SKILL.md
+++ b/.claude/skills/meeting/SKILL.md
@@ -1,7 +1,7 @@
 ---
 name: meeting
 description: Start, stop, or query the meeting assistant
-argument-hint: "start|stop|status|inject [options]"
+argument-hint: "start|stop|status|inject|minutes|actions|tasks|list [options]"
 ---
 
 # Meeting Assistant Skill
@@ -10,10 +10,19 @@ Control the real-time meeting assistant via the `meeting-assistant` MCP server.
 
 ## Available MCP Tools
 
+### Meeting Lifecycle
 - `start_meeting` — Create a Google Doc and begin the live-notes update cycle
-- `stop_meeting` — Halt the cycle and return the full transcript
+- `stop_meeting` — Halt the cycle, generate structured minutes, return both doc URLs
+- `get_meeting_status` — Show current session info (duration, line count, doc links)
+- `list_meetings` — List past meeting sessions with dates and doc URLs
+
+### Transcript Input
 - `inject_transcript` — Append a speaker line to the transcript (Phase 1 input mechanism)
 
+### Minutes & Action Items
+- `get_action_items` — Extract action items from the latest minutes doc via Claude
+- `create_tasks_from_meeting` — Write action items to a product backlog markdown file
+
 ## Argument Parsing
 
 ### `start [title]`
@@ -23,7 +32,11 @@ Call `start_meeting` with an optional title.
 
 ### `stop`
 Call `stop_meeting`.
-- Returns: full transcript text + link to the Google Doc
+- Stops live-notes cycle
+- Generates structured minutes in a second Google Doc
+- Persists transcript to `data/meetings/YYYY-MM-DD/{sessionId}.transcript.jsonl`
+- Adds cross-links between live notes and minutes docs
+- Returns: `liveNotesDocUrl`, `minutesDocUrl`, full transcript text
 
 ### `inject <speaker>: <text>`  or  `inject <text>`
 Call `inject_transcript` with the given speaker and text.
@@ -31,9 +44,24 @@ Call `inject_transcript` with the given speaker and text.
 - Returns: the appended line + running total line count
 
 ### `status`
-Report current session state from in-process memory:
-- If no meeting active: "No active meeting."
-- If active: session ID, doc URL, transcript line count, elapsed time
+Call `get_meeting_status`.
+- If meeting active: session ID, doc URL, transcript line count, elapsed time, live-notes running
+- If no meeting: "No active meeting" + last completed session summary
+
+### `list [N]`
+Call `list_meetings` with optional limit.
+- Returns the N most recent sessions (default 10), most recent first
+- Includes title, date, duration, live notes URL, minutes URL
+
+### `minutes` or `actions`
+Call `get_action_items`.
+- Extracts action items from the most recently completed meeting's minutes doc
+- Returns a JSON array of `{action, assignee, deadline, status}`
+
+### `tasks <workspace> [priority] [complexity]`
+Call `create_tasks_from_meeting` after getting action items.
+- Writes extracted action items into `backlogs/products/<workspace>.md`
+- Default priority: medium, default complexity: medium
 
 ## Examples
 
@@ -51,16 +79,58 @@ Report current session state from in-process memory:
 /meeting inject Guest: We should also update the staging environment.
 → Appends a line from speaker "Guest".
 
+/meeting status
+→ Shows current meeting session info (or last completed session).
+
 /meeting stop
-→ Stops the meeting, returns full transcript + doc link.
+→ Stops the meeting, generates structured minutes in a new Google Doc.
+→ Returns both doc URLs and the full transcript.
 
-/meeting status
-→ Shows current meeting session info.
+/meeting list
+→ Lists last 10 meetings with titles, dates, and doc links.
+
+/meeting list 5
+→ Lists last 5 meetings.
+
+/meeting actions
+→ Extracts action items from the last meeting's minutes as JSON.
+
+/meeting tasks strokmatic.visionking
+→ After running "actions", writes action items to the VisionKing backlog.
+
+/meeting tasks strokmatic.visionking high complex
+→ Writes action items at high priority, complex complexity.
+```
+
+## Two-Doc Output from stop_meeting
+
+When `stop_meeting` completes, it creates two Google Docs in the **Meeting Assistant** folder:
+
+1. **Live Notes** (created at `start_meeting`) — continuously updated during the meeting.
+   Contains a footer link: *[View structured meeting minutes →](minutesUrl)*
+
+2. **Structured Minutes** (created at `stop_meeting`) — formal post-meeting document.
+   Contains a header link: *[← View live notes](liveNotesUrl)*
+   Sections: Executive Summary, Discussion Topics, Decisions, Action Items table, Raw Transcript (collapsed).
+
+## Data Persistence
+
+After `stop_meeting`:
+- `data/meetings/YYYY-MM-DD/{sessionId}.transcript.jsonl` — full timestamped transcript (one JSON object per line)
+- `data/meetings/YYYY-MM-DD/{sessionId}.meta.json` — session metadata (updated with endedAt)
+- `data/meetings/sessions.json` — index of all completed sessions
+
+## Backlog Task Format
+
+`create_tasks_from_meeting` appends tasks to the target backlog file in the standard format:
+```
+- [ ] [complexity] Action description — Assignee: Person, Deadline: YYYY-MM-DD
 ```
 
 ## Notes
 
 - Phase 1 only: no audio capture or STT. Use `inject` to feed transcript lines manually.
 - The live-notes engine updates the Google Doc every ~30 seconds when new lines are present.
-- The Google Doc is created in the **Meeting Assistant** folder inside the JARVIS Shared Drive.
+- Both Google Docs are created in the **Meeting Assistant** folder inside the JARVIS Shared Drive.
 - Language detection is a placeholder (`detected_language: "auto"`). Future phases will auto-detect.
+- Minutes generation uses `claude-sonnet-4-6` for quality; action item extraction uses `claude-haiku-4-5-20251001` for speed.
```

#### `mcp-servers/meeting-assistant/package.json`

```diff
index c5fb28c..643892f 100644
--- a/mcp-servers/meeting-assistant/package.json
+++ b/mcp-servers/meeting-assistant/package.json
@@ -1,7 +1,7 @@
 {
   "name": "meeting-assistant-mcp",
-  "version": "0.1.0",
-  "description": "MCP server for real-time meeting assistance — Phase 1",
+  "version": "0.2.0",
+  "description": "MCP server for real-time meeting assistance — Phase 2",
   "type": "module",
   "main": "dist/index.js",
   "scripts": {
```

#### `mcp-servers/meeting-assistant/src/index.ts`

```diff
index 8be180e..262b289 100644
--- a/mcp-servers/meeting-assistant/src/index.ts
+++ b/mcp-servers/meeting-assistant/src/index.ts
@@ -1,14 +1,24 @@
 #!/usr/bin/env node
 /**
- * index.ts — Meeting Assistant MCP Server (Phase 1)
+ * index.ts — Meeting Assistant MCP Server (Phase 2)
  *
- * Exposes three MCP tools:
+ * Phase 1 tools (unchanged):
  *   - start_meeting     Create a Google Doc and start the live-notes update cycle
- *   - stop_meeting      Halt the update cycle, return full transcript
+ *   - stop_meeting      Halt the update cycle, generate minutes, return both doc URLs
  *   - inject_transcript Append a timestamped line to the transcript accumulator
  *
- * Phase 1 scope: no audio capture, no STT.  inject_transcript is the only
- * input mechanism.  Language detection is a placeholder stored in session state.
+ * Phase 2 additions:
+ *   - get_meeting_status       Current session info (duration, line count, etc.)
+ *   - list_meetings            Past sessions from data/meetings/sessions.json
+ *   - get_action_items         Extract action items from the latest minutes doc via Claude
+ *   - create_tasks_from_meeting Write action items to a product backlog markdown file
+ *
+ * Phase 2 stop_meeting changes:
+ *   - Persists full transcript to data/meetings/YYYY-MM-DD/{sessionId}.transcript.jsonl
+ *   - Generates structured minutes via MinutesGenerator (second Google Doc)
+ *   - Adds cross-links between live notes doc and minutes doc
+ *   - Updates data/meetings/sessions.json index
+ *   - Returns both live notes URL and minutes URL
  */
 
 import path from 'path';
@@ -22,6 +32,7 @@ import {
 import { GDocBridge } from './gdoc-bridge.js';
 import { TranscriptAccumulator } from './transcript.js';
 import { LiveNotesEngine } from './live-notes.js';
+import { MinutesGenerator } from './minutes-generator.js';
 
 // ---------------------------------------------------------------------------
 // Config
@@ -32,6 +43,7 @@ const ORCHESTRATOR_HOME =
 
 const CONFIG_PATH = path.join(ORCHESTRATOR_HOME, 'config', 'meeting-assistant.json');
 const DATA_DIR = path.join(ORCHESTRATOR_HOME, 'data', 'meetings');
+const BACKLOGS_DIR = path.join(ORCHESTRATOR_HOME, 'backlogs', 'products');
 
 interface MeetingConfig {
   live_notes: {
@@ -73,6 +85,26 @@ interface MeetingSession {
   detected_language: string;
 }
 
+interface CompletedSession {
+  sessionId: string;
+  title: string;
+  startedAt: string;
+  endedAt: string;
+  detected_language: string;
+  liveNotesDocId: string;
+  liveNotesDocUrl: string;
+  minutesDocId: string;
+  minutesDocUrl: string;
+  lineCount: number;
+}
+
+interface ActionItem {
+  action: string;
+  assignee: string;
+  deadline: string;
+  status: string;
+}
+
 // ---------------------------------------------------------------------------
 // MCP Server
 // ---------------------------------------------------------------------------
@@ -82,18 +114,21 @@ class MeetingAssistantServer {
   private gdoc: GDocBridge;
   private transcript: TranscriptAccumulator;
   private liveNotes: LiveNotesEngine;
+  private minutesGenerator: MinutesGenerator;
   private session: MeetingSession | null = null;
+  /** Most recently completed session — used by get_action_items without session_id. */
+  private lastSession: CompletedSession | null = null;
 
   constructor() {
     this.server = new Server(
-      { name: 'meeting-assistant', version: '0.1.0' },
+      { name: 'meeting-assistant', version: '0.2.0' },
       { capabilities: { tools: {} } },
     );
 
     this.gdoc = new GDocBridge();
     this.transcript = new TranscriptAccumulator();
-    // LiveNotesEngine is configured after loading config in run()
     this.liveNotes = new LiveNotesEngine(this.gdoc, this.transcript);
+    this.minutesGenerator = new MinutesGenerator(this.gdoc);
 
     this.setupHandlers();
 
@@ -123,6 +158,7 @@ class MeetingAssistantServer {
 
   private getToolDefinitions() {
     return [
+      // ---- Phase 1 tools ----
       {
         name: 'start_meeting',
         description:
@@ -142,7 +178,9 @@ class MeetingAssistantServer {
       {
         name: 'stop_meeting',
         description:
-          'Stop the active meeting: halt the live-notes update cycle and return the full transcript.',
+          'Stop the active meeting: halt the live-notes cycle, generate structured minutes in a new Google Doc, ' +
+          'persist the full transcript to disk, and add cross-links between the two docs. ' +
+          'Returns both the live notes URL and the minutes URL.',
         inputSchema: {
           type: 'object',
           properties: {},
@@ -170,11 +208,99 @@ class MeetingAssistantServer {
           required: ['text'],
         },
       },
+      // ---- Phase 2 tools ----
+      {
+        name: 'get_meeting_status',
+        description:
+          'Return the current meeting session status. If a meeting is active, includes session ID, ' +
+          'title, elapsed duration, live notes URL, and transcript line count. ' +
+          'If no meeting is active, reports the last completed session.',
+        inputSchema: {
+          type: 'object',
+          properties: {},
+          required: [],
+        },
+      },
+      {
+        name: 'list_meetings',
+        description:
+          'List past meeting sessions from the sessions index. Returns session metadata including ' +
+          'title, date, duration, and doc URLs.',
+        inputSchema: {
+          type: 'object',
+          properties: {
+            limit: {
+              type: 'number',
+              description: 'Maximum number of sessions to return (default: 10, most recent first).',
+            },
+          },
+          required: [],
+        },
+      },
+      {
+        name: 'get_action_items',
+        description:
+          'Extract action items from the minutes document of the most recently completed meeting ' +
+          '(or a specific past session). Returns a JSON array of {action, assignee, deadline, status}.',
+        inputSchema: {
+          type: 'object',
+          properties: {
+            session_id: {
+              type: 'string',
+              description:
+                'Session ID to extract from (e.g. "mtg-2026-02-22T10-00-00-000Z"). ' +
+                'If omitted, uses the most recently completed session.',
+            },
+          },
+          required: [],
+        },
+      },
+      {
+        name: 'create_tasks_from_meeting',
+        description:
+          'Write action items extracted from a meeting into a product backlog markdown file. ' +
+          'Appends tasks under the specified priority section following the backlog format.',
+        inputSchema: {
+          type: 'object',
+          properties: {
+            workspace: {
+              type: 'string',
+              description:
+                'Backlog workspace name (e.g. "strokmatic.visionking"). ' +
+                'The file backlogs/products/{workspace}.md must exist.',
+            },
+            action_items: {
+              type: 'array',
+              description: 'Action items to add. Each item needs at minimum an "action" field.',
+              items: {
+                type: 'object',
+                properties: {
+                  action: { type: 'string', description: 'Task description.' },
+                  assignee: { type: 'string', description: 'Person responsible.' },
+                  deadline: { type: 'string', description: 'Target deadline.' },
+                },
+                required: ['action'],
+              },
+            },
+            priority: {
+              type: 'string',
+              enum: ['high', 'medium', 'low'],
+              description: 'Priority level for all tasks (default: medium).',
+            },
+            complexity: {
+              type: 'string',
+              enum: ['simple', 'medium', 'complex'],
+              description: 'Complexity tag for all tasks (default: medium).',
+            },
+          },
+          required: ['workspace', 'action_items'],
+        },
+      },
     ];
   }
 
   // ---------------------------------------------------------------------------
-  // Tool implementations
+  // Tool implementations — Phase 1
   // ---------------------------------------------------------------------------
 
   private async startMeeting(args: { title?: string }): Promise<ReturnType<typeof this.ok>> {
@@ -245,27 +371,105 @@ class MeetingAssistantServer {
       >;
     }
 
+    // 1. Stop the live-notes update cycle
     this.liveNotes.stop();
 
+    // 2. Capture transcript before clearing state
+    const allLines = this.transcript.getAll();
     const fullTranscript = this.transcript.format();
     const session = this.session;
     const endedAt = new Date().toISOString();
 
+    // 3. Clear active session (so re-entry guard works correctly)
     this.session = null;
     this.transcript.endSession();
+
+    // 4. Persist transcript to JSONL
+    await this.persistTranscriptJsonl(session, endedAt, allLines).catch((e) =>
+      console.error('[meeting] Could not persist transcript JSONL:', e),
+    );
+
+    // 5. Read current live notes content (for passing to minutes generator)
+    let liveNotesContent = '';
+    try {
+      liveNotesContent = await this.gdoc.readDoc(session.docId);
+    } catch (err) {
+      console.error('[meeting] Failed to read live notes doc — minutes will be generated from transcript only:', err);
+    }
+
+    // 6. Generate structured minutes (new Google Doc)
+    let minutesDocId = '';
+    let minutesDocUrl = '';
+    try {
+      const result = await this.minutesGenerator.generate(
+        {
+          sessionId: session.sessionId,
+          title: session.title,
+          startedAt: session.startedAt,
+          endedAt,
+          detected_language: session.detected_language,
+        },
+        liveNotesContent,
+        allLines,
+        session.docUrl, // liveNotesUrl for cross-link header in minutes doc
+      );
+      minutesDocId = result.docId;
+      minutesDocUrl = result.url;
+      console.error(`[meeting] Minutes generated: ${minutesDocUrl}`);
+    } catch (err) {
+      console.error('[meeting] Failed to generate minutes:', err);
+    }
+
+    // 7. Add footer cross-link to live notes doc (→ minutes)
+    if (minutesDocUrl && liveNotesContent) {
+      const updatedLiveNotes =
+        liveNotesContent +
+        `\n\n---\n\n*[View structured meeting minutes →](${minutesDocUrl})*\n`;
+      await this.gdoc.replaceContent(session.docId, updatedLiveNotes).catch((e) =>
+        console.error('[meeting] Failed to add minutes cross-link to live notes:', e),
+      );
+    }
+
+    // 8. Persist completed session to sessions.json index
+    const completed: CompletedSession = {
+      sessionId: session.sessionId,
+      title: session.title,
+      startedAt: session.startedAt,
+      endedAt,
+      detected_language: session.detected_language,
+      liveNotesDocId: session.docId,
+      liveNotesDocUrl: session.docUrl,
+      minutesDocId,
+      minutesDocUrl,
+      lineCount: allLines.length,
+    };
+    await this.updateSessionsIndex(completed).catch((e) =>
+      console.error('[meeting] Could not update sessions index:', e),
+    );
+
+    // 9. Store as last session for get_action_items / status queries
+    this.lastSession = completed;
+
+    // 10. Clear transcript lines
     this.transcript.clear();
 
     return this.ok(
       JSON.stringify(
         {
           sessionId: session.sessionId,
-          docId: session.docId,
-          docUrl: session.docUrl,
+          liveNotesDocId: session.docId,
+          liveNotesDocUrl: session.docUrl,
+          minutesDocId,
+          minutesDocUrl,
           title: session.title,
           startedAt: session.startedAt,
           endedAt,
+          lineCount: allLines.length,
           transcript: fullTranscript,
-          message: 'Meeting stopped. See docUrl for live notes.',
+          message:
+            minutesDocUrl
+              ? `Meeting stopped. Live notes: ${session.docUrl} | Minutes: ${minutesDocUrl}`
+              : `Meeting stopped. Live notes: ${session.docUrl} (minutes generation failed — check logs).`,
         },
         null,
         2,
@@ -294,6 +498,229 @@ class MeetingAssistantServer {
     );
   }
 
+  // ---------------------------------------------------------------------------
+  // Tool implementations — Phase 2
+  // ---------------------------------------------------------------------------
+
+  private getMeetingStatus(): ReturnType<typeof this.ok> {
+    if (!this.session) {
+      return this.ok(
+        JSON.stringify(
+          {
+            active: false,
+            message: 'No active meeting.',
+            lastSession: this.lastSession
+              ? {
+                  sessionId: this.lastSession.sessionId,
+                  title: this.lastSession.title,
+                  endedAt: this.lastSession.endedAt,
+                  liveNotesDocUrl: this.lastSession.liveNotesDocUrl,
+                  minutesDocUrl: this.lastSession.minutesDocUrl,
+                  lineCount: this.lastSession.lineCount,
+                }
+              : null,
+          },
+          null,
+          2,
+        ),
+      );
+    }
+
+    const startedAt = new Date(this.session.startedAt);
+    const now = new Date();
+    const durationMs = now.getTime() - startedAt.getTime();
+    const durationMinutes = Math.round(durationMs / 60_000);
+
+    return this.ok(
+      JSON.stringify(
+        {
+          active: true,
+          sessionId: this.session.sessionId,
+          title: this.session.title,
+          startedAt: this.session.startedAt,
+          durationMinutes,
+          liveNotesDocUrl: this.session.docUrl,
+          transcriptLineCount: this.transcript.getCount(),
+          liveNotesRunning: this.liveNotes.isRunning(),
+          detected_language: this.session.detected_language,
+        },
+        null,
+        2,
+      ),
+    );
+  }
+
+  private async listMeetings(args: { limit?: number }): Promise<ReturnType<typeof this.ok>> {
+    const sessionsPath = path.join(DATA_DIR, 'sessions.json');
+    try {
+      const raw = await fs.readFile(sessionsPath, 'utf-8');
+      const data = JSON.parse(raw) as { sessions: CompletedSession[] };
+      const limit = args.limit ?? 10;
+      // Most recent first
+      const recent = [...data.sessions].reverse().slice(0, limit);
+      return this.ok(
+        JSON.stringify(
+          {
+            sessions: recent,
+            total: data.sessions.length,
+            showing: recent.length,
+          },
+          null,
+          2,
+        ),
+      );
+    } catch {
+      return this.ok(
+        JSON.stringify(
+          { sessions: [], total: 0, message: 'No meeting history found.' },
+          null,
+          2,
+        ),
+      );
+    }
+  }
+
+  private async getActionItems(args: { session_id?: string }): Promise<ReturnType<typeof this.ok>> {
+    // Resolve which session to use
+    let minutesDocId: string;
+
+    if (args.session_id) {
+      // Look up session from the index
+      const session = await this.findSessionById(args.session_id);
+      if (!session) {
+        return this.err(`Session not found: ${args.session_id}`) as ReturnType<typeof this.ok>;
+      }
+      minutesDocId = session.minutesDocId;
+    } else if (this.lastSession) {
+      minutesDocId = this.lastSession.minutesDocId;
+    } else {
+      return this.err(
+        'No completed session in memory. Provide a session_id or complete a meeting first.',
+      ) as ReturnType<typeof this.ok>;
+    }
+
+    if (!minutesDocId) {
+      return this.err(
+        'No minutes document found for this session (minutes generation may have failed).',
+      ) as ReturnType<typeof this.ok>;
+    }
+
+    // Read the minutes document
+    let minutesContent: string;
+    try {
+      minutesContent = await this.gdoc.readDoc(minutesDocId);
+    } catch (err: unknown) {
+      const msg = err instanceof Error ? err.message : String(err);
+      return this.err(`Failed to read minutes document: ${msg}`) as ReturnType<typeof this.ok>;
+    }
+
+    // Extract action items via Claude
+    const jsonResult = this.minutesGenerator.extractActionItems(minutesContent);
+    if (!jsonResult) {
+      return this.err('Claude returned empty output when extracting action items.') as ReturnType<
+        typeof this.ok
+      >;
+    }
+
+    // Validate JSON before returning
+    try {
+      JSON.parse(jsonResult);
+    } catch {
+      // Return raw output even if not valid JSON — caller can inspect
+      return this.ok(jsonResult);
+    }
+
+    return this.ok(jsonResult);
+  }
+
+  private async createTasksFromMeeting(args: {
+    workspace: string;
+    action_items: ActionItem[];
+    priority?: string;
+    complexity?: string;
+  }): Promise<ReturnType<typeof this.ok>> {
+    const { workspace, action_items } = args;
+    const priority = args.priority ?? 'medium';
+    const complexity = args.complexity ?? 'medium';
+
+    if (!action_items || action_items.length === 0) {
+      return this.err('No action items provided.') as ReturnType<typeof this.ok>;
+    }
+
+    const backlogPath = path.join(BACKLOGS_DIR, `${workspace}.md`);
+
+    // Read existing backlog
+    let content: string;
+    try {
+      content = await fs.readFile(backlogPath, 'utf-8');
+    } catch {
+      return this.err(
+        `Backlog file not found: backlogs/products/${workspace}.md. ` +
+          'Create the file first or use an existing workspace name.',
+      ) as ReturnType<typeof this.ok>;
+    }
+
+    // Build task lines following the backlog format:
+    // - [ ] [complexity] Task description — Assignee: X, Deadline: Y
+    const taskLines = action_items.map((item) => {
+      let line = `- [ ] [${complexity}] ${item.action.trim()}`;
+      const meta: string[] = [];
+      if (item.assignee && item.assignee !== 'Unassigned') {
+        meta.push(`Assignee: ${item.assignee}`);
+      }
+      if (item.deadline && item.deadline !== 'Not specified') {
+        meta.push(`Deadline: ${item.deadline}`);
+      }
+      if (meta.length > 0) {
+        line += ` — ${meta.join(', ')}`;
+      }
+      return line;
+    });
+
+    // Find the priority section and insert tasks
+    const priorityHeader = `## ${priority.charAt(0).toUpperCase() + priority.slice(1)} Priority`;
+    const sectionMarker = priorityHeader.replace('## ', '');
+
+    const sections = content.split('\n## ');
+    let inserted = false;
+
+    for (let i = 0; i < sections.length; i++) {
+      if (sections[i].startsWith(sectionMarker)) {
+        const lines = sections[i].split('\n');
+        // Insert after the section header line (index 0)
+        lines.splice(1, 0, ...taskLines);
+        sections[i] = lines.join('\n');
+        inserted = true;
+        break;
+      }
+    }
+
+    if (!inserted) {
+      // Append a new section at the end
+      content = content.trimEnd() + `\n\n${priorityHeader}\n` + taskLines.join('\n') + '\n';
+    } else {
+      content = sections.join('\n## ');
+    }
+
+    await fs.writeFile(backlogPath, content, 'utf-8');
+
+    return this.ok(
+      JSON.stringify(
+        {
+          ok: true,
+          workspace,
+          tasksAdded: taskLines.length,
+          priority,
+          complexity,
+          tasks: taskLines,
+          backlogPath: `backlogs/products/${workspace}.md`,
+        },
+        null,
+        2,
+      ),
+    );
+  }
+
   // ---------------------------------------------------------------------------
   // Persistence helpers
   // ---------------------------------------------------------------------------
@@ -305,6 +732,73 @@ class MeetingAssistantServer {
     await fs.writeFile(metaPath, JSON.stringify(session, null, 2), 'utf-8');
   }
 
+  /**
+   * Persist all transcript lines to a JSONL file (one JSON object per line).
+   * File: data/meetings/YYYY-MM-DD/{sessionId}.transcript.jsonl
+   */
+  private async persistTranscriptJsonl(
+    session: MeetingSession,
+    endedAt: string,
+    lines: Array<{ timestamp: string; speaker: string; text: string }>,
+  ): Promise<void> {
+    const dir = path.join(DATA_DIR, session.startedAt.slice(0, 10));
+    await fs.mkdir(dir, { recursive: true });
+    const jsonlPath = path.join(dir, `${session.sessionId}.transcript.jsonl`);
+    const content = lines.map((l) => JSON.stringify(l)).join('\n') + (lines.length > 0 ? '\n' : '');
+    await fs.writeFile(jsonlPath, content, 'utf-8');
+    console.error(`[meeting] Transcript persisted: ${jsonlPath} (${lines.length} lines)`);
+
+    // Also update the meta.json with endedAt and line count
+    const metaPath = path.join(dir, `${session.sessionId}.meta.json`);
+    try {
+      const existingMeta = JSON.parse(await fs.readFile(metaPath, 'utf-8')) as Record<string, unknown>;
+      existingMeta.endedAt = endedAt;
+      existingMeta.lineCount = lines.length;
+      await fs.writeFile(metaPath, JSON.stringify(existingMeta, null, 2), 'utf-8');
+    } catch {
+      // meta.json may not exist yet — create a minimal one
+      await fs.writeFile(
+        metaPath,
+        JSON.stringify({ ...session, endedAt, lineCount: lines.length }, null, 2),
+        'utf-8',
+      );
+    }
+  }
+
+  /**
+   * Append a completed session to data/meetings/sessions.json.
+   * Creates the file if it does not exist.
+   */
+  private async updateSessionsIndex(completed: CompletedSession): Promise<void> {
+    await fs.mkdir(DATA_DIR, { recursive: true });
+    const sessionsPath = path.join(DATA_DIR, 'sessions.json');
+
+    let existing: CompletedSession[] = [];
+    try {
+      const raw = await fs.readFile(sessionsPath, 'utf-8');
+      existing = (JSON.parse(raw) as { sessions: CompletedSession[] }).sessions;
+    } catch {
+      // First session — start fresh
+    }
+
+    existing.push(completed);
+    await fs.writeFile(sessionsPath, JSON.stringify({ sessions: existing }, null, 2), 'utf-8');
+  }
+
+  /**
+   * Find a session by ID in the sessions.json index.
+   */
+  private async findSessionById(sessionId: string): Promise<CompletedSession | null> {
+    try {
+      const sessionsPath = path.join(DATA_DIR, 'sessions.json');
+      const raw = await fs.readFile(sessionsPath, 'utf-8');
+      const { sessions } = JSON.parse(raw) as { sessions: CompletedSession[] };
+      return sessions.find((s) => s.sessionId === sessionId) ?? null;
+    } catch {
+      return null;
+    }
+  }
+
   // ---------------------------------------------------------------------------
   // Handler setup
   // ---------------------------------------------------------------------------
@@ -327,6 +821,21 @@ class MeetingAssistantServer {
             return this.injectTranscript(
               (args ?? {}) as { text: string; speaker?: string },
             );
+          case 'get_meeting_status':
+            return this.getMeetingStatus();
+          case 'list_meetings':
+            return await this.listMeetings((args ?? {}) as { limit?: number });
+          case 'get_action_items':
+            return await this.getActionItems((args ?? {}) as { session_id?: string });
+          case 'create_tasks_from_meeting':
+            return await this.createTasksFromMeeting(
+              (args ?? {}) as {
+                workspace: string;
+                action_items: ActionItem[];
+                priority?: string;
+                complexity?: string;
+              },
+            );
           default:
             throw new Error(`Unknown tool: ${name}`);
         }
@@ -352,7 +861,7 @@ class MeetingAssistantServer {
 
     const transport = new StdioServerTransport();
     await this.server.connect(transport);
-    console.error('Meeting Assistant MCP server running on stdio');
+    console.error('Meeting Assistant MCP server running on stdio (Phase 2)');
   }
 }
 
```

#### `mcp-servers/meeting-assistant/src/minutes-generator.ts`

```diff
new file mode 100644
index 0000000..ea5d1be
--- /dev/null
+++ b/mcp-servers/meeting-assistant/src/minutes-generator.ts
@@ -0,0 +1,254 @@
+/**
+ * minutes-generator.ts
+ *
+ * Post-meeting structured minutes generator.
+ * Called by stop_meeting after the live-notes cycle ends.
+ *
+ * Generates a formal Google Doc with:
+ *   - Executive summary
+ *   - Discussion topics with context
+ *   - Decisions with rationale
+ *   - Action items table (assignee, deadline, status)
+ *   - Raw transcript in a collapsed <details> section
+ *
+ * Written in the same detected_language as the live notes.
+ * Uses claude --print via spawnSync (same pattern as live-notes.ts).
+ */
+
+import { spawnSync } from 'child_process';
+import type { GDocBridge } from './gdoc-bridge.js';
+import type { TranscriptLine } from './transcript.js';
+
+// Use a more capable model for post-meeting processing (quality > latency)
+const MINUTES_MODEL = 'claude-sonnet-4-6';
+// Use a faster model for quick extraction tasks (action items)
+const EXTRACT_MODEL = 'claude-haiku-4-5-20251001';
+
+export interface MinutesResult {
+  docId: string;
+  url: string;
+}
+
+export interface SessionInfo {
+  sessionId: string;
+  title: string;
+  startedAt: string;
+  endedAt: string;
+  /** Language detected during the meeting. 'auto' means auto-detect from transcript. */
+  detected_language: string;
+}
+
+export class MinutesGenerator {
+  constructor(private readonly gdoc: GDocBridge) {}
+
+  // ---------------------------------------------------------------------------
+  // Main generation
+  // ---------------------------------------------------------------------------
+
+  /**
+   * Generate structured meeting minutes and publish them to a new Google Doc.
+   *
+   * @param session           Session metadata (title, times, language)
+   * @param liveNotesContent  Current content of the live notes doc (with participant edits)
+   * @param transcriptLines   Full raw transcript lines
+   * @param liveNotesUrl      URL of the live notes doc (for cross-linking)
+   * @returns { docId, url } of the generated minutes doc
+   */
+  async generate(
+    session: SessionInfo,
+    liveNotesContent: string,
+    transcriptLines: TranscriptLine[],
+    liveNotesUrl?: string,
+  ): Promise<MinutesResult> {
+    const rawTranscript = transcriptLines
+      .map((l) => `[${l.timestamp}] ${l.speaker}: ${l.text}`)
+      .join('\n');
+
+    const wordCount = rawTranscript.split(/\s+/).filter(Boolean).length;
+
+    // Generate the main minutes body via Claude
+    const prompt = buildMinutesPrompt(session, liveNotesContent, rawTranscript);
+    const minutesBody = this.callClaude(prompt, MINUTES_MODEL);
+
+    if (!minutesBody) {
+      throw new Error('[minutes-generator] Claude returned empty output — cannot create minutes.');
+    }
+
+    // Assemble full doc content:
+    //   1. Optional back-link to live notes (cross-link header)
+    //   2. Claude-generated body (executive summary → action items)
+    //   3. Raw transcript in a collapsible section
+    let fullContent = '';
+
+    if (liveNotesUrl) {
+      fullContent += `*[← View live notes](${liveNotesUrl})*\n\n---\n\n`;
+    }
+
+    fullContent += minutesBody;
+    fullContent += '\n\n' + buildRawTranscriptSection(rawTranscript, wordCount);
+
+    // Create the Google Doc
+    const minutesTitle = `Minutes — ${session.title}`;
+    const { docId, url } = await this.gdoc.createDoc(minutesTitle, fullContent);
+
+    return { docId, url };
+  }
+
+  // ---------------------------------------------------------------------------
+  // Action items extraction
+  // ---------------------------------------------------------------------------
+
+  /**
+   * Extract action items from a minutes document using Claude.
+   * Returns a JSON-formatted list of action items.
+   *
+   * @param minutesContent  Plain text of the minutes doc
+   * @returns JSON string with array of action items
+   */
+  extractActionItems(minutesContent: string): string {
+    const prompt = buildActionItemsPrompt(minutesContent);
+    return this.callClaude(prompt, EXTRACT_MODEL);
+  }
+
+  // ---------------------------------------------------------------------------
+  // Private: Claude invocation
+  // ---------------------------------------------------------------------------
+
+  /**
+   * Calls `claude --print` with the prompt via stdin.
+   * Per JARVIS lessons learned: pipe prompt via stdin (not CLI arg) to avoid escaping issues.
+   */
+  private callClaude(prompt: string, model: string): string {
+    const result = spawnSync('claude', ['--print', '--model', model], {
+      input: prompt,
+      encoding: 'utf-8',
+      timeout: 180_000, // 3 minutes for post-meeting processing
+      maxBuffer: 10 * 1024 * 1024,
+    });
+
+    if (result.error) {
+      console.error('[minutes-generator] claude spawn error:', result.error.message);
+      return '';
+    }
+    if (result.status !== 0) {
+      console.error(
+        '[minutes-generator] claude exited with status',
+        result.status,
+        result.stderr ?? '',
+      );
+      return '';
+    }
+
+    return (result.stdout ?? '').trim();
+  }
+}
+
+// ---------------------------------------------------------------------------
+// Prompt builders
+// ---------------------------------------------------------------------------
+
+function buildMinutesPrompt(
+  session: SessionInfo,
+  liveNotesContent: string,
+  rawTranscript: string,
+): string {
+  const startedAt = new Date(session.startedAt);
+  const endedAt = new Date(session.endedAt);
+  const durationMs = endedAt.getTime() - startedAt.getTime();
+  const durationMin = Math.round(durationMs / 60_000);
+
+  const dateStr = startedAt.toLocaleDateString('en-US', {
+    weekday: 'long',
+    year: 'numeric',
+    month: 'long',
+    day: 'numeric',
+  });
+
+  const languageInstruction =
+    session.detected_language && session.detected_language !== 'auto'
+      ? `Write the minutes in ${session.detected_language}.`
+      : 'Write the minutes in the same language as the transcript content.';
+
+  return `You are a professional meeting minutes writer. ${languageInstruction}
+Generate formal, structured meeting minutes using the live notes and raw transcript below.
+
+MEETING METADATA:
+- Title: ${session.title}
+- Date: ${dateStr}
+- Duration: ${durationMin} minutes
+- Start: ${session.startedAt}
+- End: ${session.endedAt}
+
+LIVE NOTES (compiled by AI assistant during the meeting — may include participant corrections):
+${liveNotesContent.trim() || '(No live notes available)'}
+
+RAW TRANSCRIPT:
+${rawTranscript.trim() || '(No transcript available)'}
+
+Generate meeting minutes in this EXACT markdown format. Do NOT include a Raw Transcript section (it will be added separately as a collapsed section). Return ONLY the markdown, no preamble or explanation:
+
+# Meeting Minutes — ${session.title}
+
+**Date:** ${dateStr}
+**Duration:** ${durationMin} minutes
+**Attendees:** [list unique speakers found in transcript; if none found, write "Unknown"]
+
+## Executive Summary
+[Write one comprehensive paragraph summarizing what the meeting was about, the main outcomes, and the most important decisions or action items.]
+
+## Discussion Topics
+
+### [Topic 1 — infer meaningful topic name from content]
+[Summarize the key points discussed, including context and background. Use bullet points for sub-points.]
+
+### [Topic 2 — add more sections as needed]
+[Key points, context, any follow-up questions raised.]
+
+## Decisions
+
+[List each formal decision made, with brief rationale. Format each as:
+"**Decision:** [what was decided] — **Rationale:** [why this decision was made]"
+
+If no formal decisions were recorded, write exactly: "No formal decisions recorded."]
+
+## Action Items
+
+| # | Action | Assignee | Deadline | Status |
+|---|--------|----------|----------|--------|
+[One row per action item extracted from the meeting. If no action items, include a single row with "No action items recorded" in the Action column and dashes in the remaining columns.]
+
+## Key Takeaways
+
+[2-5 bullet points capturing the most important insights, outcomes, or next steps from the meeting.]`;
+}
+
+function buildActionItemsPrompt(minutesContent: string): string {
+  return `Extract all action items from the following meeting minutes document.
+
+Return ONLY a valid JSON array. Each element must be an object with these fields:
+- "action": string — the task or action to be done
+- "assignee": string — the person responsible (use "Unassigned" if not specified)
+- "deadline": string — the deadline (use "Not specified" if not mentioned)
+- "status": string — always "Pending" for newly extracted items
+
+If there are no action items, return an empty JSON array: []
+
+MEETING MINUTES:
+${minutesContent}
+
+Return ONLY the JSON array, no explanation, no markdown fences:`;
+}
+
+function buildRawTranscriptSection(rawTranscript: string, wordCount: number): string {
+  return `## Raw Transcript
+
+<details>
+<summary>Full transcript (${wordCount} words)</summary>
+
+\`\`\`
+${rawTranscript || '(No transcript recorded)'}
+\`\`\`
+
+</details>
+`;
+}
```

---

## Apply Instructions

Patches at: `/tmp/jarvis-sandbox-20260222-123426-GKCoZ/`

```bash
# Apply
cd /home/teruel/JARVIS && git am /tmp/jarvis-sandbox-20260222-123426-GKCoZ/*.patch

# Discard
rm -rf /tmp/jarvis-sandbox-20260222-123426-GKCoZ
```
