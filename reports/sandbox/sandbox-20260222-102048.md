# Sandbox Report: sandbox/20260222-102048

**Date:** 2026-02-22 10:30<br>
**Task:** Implement Phase 1 of the Meeting Assistant MCP server. Scope: (1) Scaffold the MCP server at mcp-servers/meeting-assistant/ with package.json, tsconfig.json, and TypeScript source. (2) Implement Google Docs bridge (gdoc-bridge.ts) using the googleapis npm package directly — create, read, update Google Docs in the 'Meeting Assistant' folder inside the JARVIS Shared Drive (Drive ID: 0AC4RjZu6DAzcUk9PVA). Use the same service account pattern as mcp-servers/google-workspace/index.js (JWT auth with domain-wide delegation, impersonating pedro@lumesolutions.com, credentials at config/credentials/gcp-service-account.json). (3) Implement transcript accumulator (transcript.ts) — stores timestamped lines with speaker labels. (4) Implement the live notes update engine (live-notes.ts) — every ~30s reads full Google Doc, reads new transcript, calls claude --print to update notes, writes back to doc. (5) Create inject_transcript MCP tool for testing without audio — accepts text + speaker and appends to accumulator. (6) Create start_meeting and stop_meeting MCP tools. start_meeting creates a new Google Doc and begins the update cycle. stop_meeting halts the cycle. (7) Create config/meeting-assistant.json with the live_notes section from the spec. (8) Create the /meeting skill at .claude/skills/meeting/SKILL.md. (9) Language detection is a placeholder — store detected_language in session state, default to 'auto'. Do NOT implement audio capture or STT in this phase — those come later. The inject_transcript tool is the only input mechanism for Phase 1.<br>
**Spec:** backlogs/orchestrator/meeting-assistant.md<br>
**Model:** sonnet<br>
**Branch:** sandbox/20260222-102048<br>
**Base:** develop<br>
**Duration:** 9m 24s<br>
**Exit code:** 0<br>
**Patches:** 1

---

# Implementation Report

## Task

Implement Phase 1 of the Meeting Assistant MCP server: scaffold a TypeScript MCP server with a Google Docs bridge, transcript accumulator, live-notes update engine, three MCP tools (start_meeting, stop_meeting, inject_transcript), a config file, and a /meeting skill.

## Approach

1. **Read CLAUDE.md** to understand project conventions (session directives, MCP tool patterns, changelog format, commit style).
2. **Explored `mcp-servers/google-workspace/index.js`** — the reference implementation for Google auth, Drive/Docs API usage, and MCP server structure. Extracted the exact auth pattern: `google.auth.GoogleAuth` with JWT credentials + `clientOptions.subject` for domain-wide delegation impersonating `pedro@lumesolutions.com`.
3. **Read existing skill files** (jarvis, gdoc) to understand the SKILL.md YAML frontmatter format and argument-parsing conventions.
4. **Planned TypeScript module layout**: four source files in `src/`, compiled to `dist/` via `tsc`. Used Node16 module resolution so `.js` extension imports work correctly with ES modules at runtime.
5. **Referenced CLAUDE.md Lessons Learned** for the `claude --print` pitfalls — specifically using `spawnSync` with `input:` to pipe prompts via stdin rather than passing them as CLI arguments.

## Exploration & Findings

- All existing MCP servers are plain JavaScript (`type: "module"`, ES imports). The task explicitly requested TypeScript, so I introduced a TypeScript build pipeline as a first-class addition to the project.
- The google-workspace server uses `@modelcontextprotocol/sdk: ^0.5.0`. For TypeScript typings, I used `^1.0.0` which ships complete `.d.ts` declarations. The API surface (Server, StdioServerTransport, ListToolsRequestSchema, CallToolRequestSchema) is identical at both versions.
- The JARVIS Shared Drive ID (`0AC4RjZu6DAzcUk9PVA`) is not stored anywhere in the config directory. I embedded it in `config/meeting-assistant.json` under `live_notes.google_drive_id` so it's configurable without recompiling.
- CLAUDE.md explicitly warns: "`claude --print` cannot receive long prompts as CLI arguments … pipe via stdin instead." Applied directly in `live-notes.ts` using `spawnSync` with `input:` parameter.
- The `config/` directory contains individual product config files (`clickup.json`, `notifications.json`, etc.). `meeting-assistant.json` follows this exact pattern.

## Implementation

### `mcp-servers/meeting-assistant/package.json`
ES module package with TypeScript build pipeline. Dependencies: `@modelcontextprotocol/sdk@^1.0.0`, `googleapis@^144.0.0`. Dev: `typescript@^5.0.0`, `@types/node@^20.0.0`.

### `mcp-servers/meeting-assistant/tsconfig.json`
`module: "Node16"` + `moduleResolution: "Node16"` — the correct combination for Node.js native ES modules with TypeScript. Compiles `src/` → `dist/` with declaration files.

### `src/gdoc-bridge.ts`
Google Docs bridge. Key design choices:
- **Auth**: mirrors google-workspace/index.js exactly — `google.auth.GoogleAuth` with JSON service account credentials, `clientOptions.subject: "pedro@lumesolutions.com"` for domain-wide delegation.
- **Folder discovery**: `getMeetingFolderId()` searches the JARVIS Shared Drive for `name='Meeting Assistant'` via `drive.files.list` with `driveId` + `corpora: 'drive'`. Creates the folder if absent.
- **Doc creation**: Creates in user's My Drive (Docs API), then moves to Meeting folder via `drive.files.update` (addParents/removeParents) — same two-step pattern as google-workspace.
- **Content update**: `replaceContent()` reads the current end index, deletes the body, then inserts new text as a single `batchUpdate`. Reuses the `withRetry()` wrapper for 429/503 resilience.
- **Plain text extraction**: `docToPlainText()` walks `body.content[].paragraph.elements[].textRun.content`, stripping the trailing `\n` the API appends per paragraph.

### `src/transcript.ts`
Simple in-memory accumulator. `TranscriptLine` interface: `{ timestamp, speaker, text }`. Key methods:
- `append(speaker, text)` — pushes with `new Date().toISOString()` timestamp
- `getSince(index)` — slice from index (used by live-notes to fetch only new lines)
- `format(lines?)` — produces `[ISO] Speaker: text` strings for Claude prompts
- `startSession(id)` / `endSession()` — lifecycle markers (clears lines on start)

### `src/live-notes.ts`
Periodic update engine. Uses `setInterval` at the configured interval (default 30s). Each tick:
1. `getSince(lastProcessedIndex)` — only new lines
2. Skips if nothing new
3. Reads current doc via `gdoc.readDoc()`
4. Builds a prompt (two modes: create-from-scratch if doc is empty, or integrate-into-existing-notes)
5. Calls `claude --print` via `spawnSync('claude', ['--print', '--model', model], { input: prompt })` — stdin-piped to avoid shell escaping issues (per CLAUDE.md lesson)
6. Writes result back via `gdoc.replaceContent()`

### `src/index.ts`
MCP server entrypoint. Three tools:

| Tool | Params | Returns |
|------|--------|---------|
| `start_meeting` | `title?` | sessionId, docId, docUrl, detected_language |
| `stop_meeting` | — | full transcript text, docUrl |
| `inject_transcript` | `text`, `speaker?` | appended line, total count |

Session state (`MeetingSession`) includes `detected_language: "auto"` as a Phase 1 placeholder. Config is loaded from `config/meeting-assistant.json` at startup via `loadConfig()` with sensible fallback defaults. Session metadata is persisted to `data/meetings/YYYY-MM-DD/<sessionId>.meta.json`.

### `config/meeting-assistant.json`
Contains `live_notes` section (interval, model, drive ID, folder name) plus `stt` and `proactive_actions` stubs for future phases — matching the spec exactly.

### `.claude/skills/meeting/SKILL.md`
Skill with YAML frontmatter (`name`, `description`, `argument-hint`). Documents four argument forms: `start [title]`, `stop`, `inject <speaker>: <text>`, `status`. Includes worked examples.

## Tests & Validation

```
npm install   → 119 packages added, 0 vulnerabilities
npm run build → tsc: 0 errors, 0 warnings
```

Smoke tests (run from `mcp-servers/meeting-assistant/`):

```js
// TranscriptAccumulator
t.startSession('test-001');
t.append('Pedro', 'Hello world');
// → { timestamp: '2026-02-22T13:27:51.837Z', speaker: 'Pedro', text: 'Hello world' }
// → Count: 1, Format: "[2026-02-22T13:27:51.837Z] Pedro: Hello world"  ✓

// Module import structural check
import { GDocBridge } from './dist/gdoc-bridge.js';   // ✓
import { TranscriptAccumulator } from './dist/transcript.js'; // ✓
import { LiveNotesEngine } from './dist/live-notes.js';       // ✓
// GDocBridge.createDoc: function ✓
// LiveNotesEngine.isRunning(): false ✓
```

No test framework exists in the project — smoke tests were run inline.

## Issues & Resolutions

**1. MCP SDK version for TypeScript**
The existing JS servers use `@modelcontextprotocol/sdk@^0.5.0` which has no TypeScript declarations. Used `^1.0.0` for proper typings. The API surface (Server, StdioServerTransport, the schema types) is identical.

**2. `Node16` module resolution requires `.js` imports in TypeScript**
With `module: "Node16"`, TypeScript enforces that cross-file imports use the `.js` extension (which maps to the compiled file at runtime). Initially forgot this — added `.js` to all local imports.

**3. Google Drive Shared Drive API requires `supportsAllDrives: true`**
Without this flag, `drive.files.get()` on a file inside a Shared Drive returns a 404. Verified against the google-workspace pattern which consistently passes `supportsAllDrives: true` and `includeItemsFromAllDrives: true`.

**4. `claude --print` stdin piping**
CLAUDE.md explicitly warns that passing prompts as CLI arguments breaks on special characters and that `claude --print` inside loops consumes stdin. Used `spawnSync` with `input: prompt` (not `echo | claude`) to pipe the prompt directly, avoiding both issues.

**5. TypeScript strict mode + `any` in googleapis responses**
The googleapis types use `any` in several places (e.g. `documents.get()` response `body`). Added targeted `// eslint-disable-next-line @typescript-eslint/no-explicit-any` comments rather than loosening strict mode globally.

## Files Changed

| File | Change |
|------|--------|
| `mcp-servers/meeting-assistant/package.json` | New — ES module package, TypeScript build pipeline |
| `mcp-servers/meeting-assistant/tsconfig.json` | New — Node16 module resolution, src→dist |
| `mcp-servers/meeting-assistant/.gitignore` | New — excludes node_modules/ and dist/ |
| `mcp-servers/meeting-assistant/src/gdoc-bridge.ts` | New — Google Docs bridge with service account auth |
| `mcp-servers/meeting-assistant/src/transcript.ts` | New — In-memory transcript accumulator |
| `mcp-servers/meeting-assistant/src/live-notes.ts` | New — 30s periodic notes update engine |
| `mcp-servers/meeting-assistant/src/index.ts` | New — MCP server with 3 tools + session state |
| `config/meeting-assistant.json` | New — live_notes config + STT/actions stubs |
| `.claude/skills/meeting/SKILL.md` | New — /meeting skill definition |

## Lessons Learned

- **`@modelcontextprotocol/sdk@^1.0.0` is the right choice for TypeScript MCP servers** — the 0.5.x versions have no TypeScript declarations. The API is backward compatible so existing JS servers are unaffected.
- **`module: "Node16"` in tsconfig enforces `.js` imports** — all local TypeScript imports must end in `.js` (the compiled output extension). This is correct and required for native Node.js ES module resolution; don't fight it.
- **Shared Drive files need `supportsAllDrives: true` on every Drive API call** — not just the list call. Missing it on `files.get()` produces a cryptic 404.
- **`spawnSync` with `input:` is the cleanest way to call `claude --print`** — avoids both shell-escaping issues and the stdin-consumption problem described in CLAUDE.md lessons.
- **Building TypeScript MCP servers introduces a compile step** — the `dist/` directory must be built before the server can run. The `npm run build` script handles this, and the `.gitignore` excludes the compiled output (source is the canonical artifact).

---

## Safety Audit

No sensitive files or suspicious patterns detected.

## Diff Summary

```
 0 files changed
```

## Full Diff

### Patch: 0001-feat-implement-Meeting-Assistant-MCP-server-Phase-1.patch

#### `.claude/skills/meeting/SKILL.md`

```diff
new file mode 100644
index 0000000..2eacbce
--- /dev/null
+++ b/.claude/skills/meeting/SKILL.md
@@ -0,0 +1,66 @@
+---
+name: meeting
+description: Start, stop, or query the meeting assistant
+argument-hint: "start|stop|status|inject [options]"
+---
+
+# Meeting Assistant Skill
+
+Control the real-time meeting assistant via the `meeting-assistant` MCP server.
+
+## Available MCP Tools
+
+- `start_meeting` — Create a Google Doc and begin the live-notes update cycle
+- `stop_meeting` — Halt the cycle and return the full transcript
+- `inject_transcript` — Append a speaker line to the transcript (Phase 1 input mechanism)
+
+## Argument Parsing
+
+### `start [title]`
+Call `start_meeting` with an optional title.
+- No title → use a timestamped default (e.g. "Meeting 2/22/2026 10:30 AM")
+- Returns: `sessionId`, `docId`, `docUrl`, confirmation message
+
+### `stop`
+Call `stop_meeting`.
+- Returns: full transcript text + link to the Google Doc
+
+### `inject <speaker>: <text>`  or  `inject <text>`
+Call `inject_transcript` with the given speaker and text.
+- If no colon separator, use "Speaker" as the default label
+- Returns: the appended line + running total line count
+
+### `status`
+Report current session state from in-process memory:
+- If no meeting active: "No active meeting."
+- If active: session ID, doc URL, transcript line count, elapsed time
+
+## Examples
+
+```
+/meeting start
+→ Starts a meeting with a default timestamped title.
+→ Returns the Google Doc URL for live notes.
+
+/meeting start "Sprint Review Q1 2026"
+→ Starts a meeting with the given title.
+
+/meeting inject Pedro: The CI pipeline needs to be fixed by Friday.
+→ Appends a transcript line from speaker "Pedro".
+
+/meeting inject Guest: We should also update the staging environment.
+→ Appends a line from speaker "Guest".
+
+/meeting stop
+→ Stops the meeting, returns full transcript + doc link.
+
+/meeting status
+→ Shows current meeting session info.
+```
+
+## Notes
+
+- Phase 1 only: no audio capture or STT. Use `inject` to feed transcript lines manually.
+- The live-notes engine updates the Google Doc every ~30 seconds when new lines are present.
+- The Google Doc is created in the **Meeting Assistant** folder inside the JARVIS Shared Drive.
+- Language detection is a placeholder (`detected_language: "auto"`). Future phases will auto-detect.
```

#### `config/meeting-assistant.json`

```diff
new file mode 100644
index 0000000..1ff7779
--- /dev/null
+++ b/config/meeting-assistant.json
@@ -0,0 +1,29 @@
+{
+  "live_notes": {
+    "update_interval_ms": 30000,
+    "model": "claude-haiku-4-5-20251001",
+    "google_drive_id": "0AC4RjZu6DAzcUk9PVA",
+    "folder_name": "Meeting Assistant"
+  },
+  "stt": {
+    "default_provider": "deepgram",
+    "deepgram": {
+      "api_key_env": "DEEPGRAM_API_KEY",
+      "model": "nova-2",
+      "language": "multi",
+      "diarize": true
+    },
+    "whisper": {
+      "model_size": "large-v3",
+      "device": "auto",
+      "compute_type": "float16",
+      "language": "auto",
+      "vad_filter": true
+    }
+  },
+  "proactive_actions": {
+    "mode": "both",
+    "realtime_triggers": ["action_item", "decision", "deadline", "assigned_to_user"],
+    "post_meeting": true
+  }
+}
```

#### `mcp-servers/meeting-assistant/.gitignore`

```diff
new file mode 100644
index 0000000..b947077
--- /dev/null
+++ b/mcp-servers/meeting-assistant/.gitignore
@@ -0,0 +1,2 @@
+node_modules/
+dist/
```

#### `mcp-servers/meeting-assistant/package.json`

```diff
new file mode 100644
index 0000000..c5fb28c
--- /dev/null
+++ b/mcp-servers/meeting-assistant/package.json
@@ -0,0 +1,20 @@
+{
+  "name": "meeting-assistant-mcp",
+  "version": "0.1.0",
+  "description": "MCP server for real-time meeting assistance — Phase 1",
+  "type": "module",
+  "main": "dist/index.js",
+  "scripts": {
+    "build": "tsc",
+    "start": "node dist/index.js",
+    "dev": "tsc --watch"
+  },
+  "dependencies": {
+    "@modelcontextprotocol/sdk": "^1.0.0",
+    "googleapis": "^144.0.0"
+  },
+  "devDependencies": {
+    "@types/node": "^20.0.0",
+    "typescript": "^5.0.0"
+  }
+}
```

#### `mcp-servers/meeting-assistant/src/gdoc-bridge.ts`

```diff
new file mode 100644
index 0000000..ff945e9
--- /dev/null
+++ b/mcp-servers/meeting-assistant/src/gdoc-bridge.ts
@@ -0,0 +1,257 @@
+/**
+ * gdoc-bridge.ts
+ *
+ * Google Docs bridge for the Meeting Assistant.
+ * Uses the same service-account JWT auth pattern as mcp-servers/google-workspace/index.js,
+ * impersonating pedro@lumesolutions.com via domain-wide delegation.
+ *
+ * Creates/reads/updates Google Docs in the 'Meeting Assistant' folder
+ * inside the JARVIS Shared Drive (Drive ID: 0AC4RjZu6DAzcUk9PVA).
+ */
+
+import fs from 'fs/promises';
+import path from 'path';
+import { google } from 'googleapis';
+
+const ORCHESTRATOR_HOME =
+  process.env.ORCHESTRATOR_HOME ?? path.join(process.env.HOME ?? '/root', 'JARVIS');
+
+const SERVICE_ACCOUNT_PATH = path.join(
+  ORCHESTRATOR_HOME,
+  'config',
+  'credentials',
+  'gcp-service-account.json',
+);
+
+const IMPERSONATED_USER = 'pedro@lumesolutions.com';
+const JARVIS_DRIVE_ID = '0AC4RjZu6DAzcUk9PVA';
+const MEETING_FOLDER_NAME = 'Meeting Assistant';
+
+// ---------------------------------------------------------------------------
+// Retry wrapper (mirrors google-workspace/index.js pattern)
+// ---------------------------------------------------------------------------
+
+async function withRetry<T>(
+  fn: () => Promise<T>,
+  maxAttempts = 3,
+  delayMs = 1000,
+): Promise<T> {
+  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
+    try {
+      return await fn();
+    } catch (error: unknown) {
+      const err = error as { response?: { status?: number }; code?: number };
+      const status = err?.response?.status ?? err?.code;
+      const isRateLimit = status === 429 || status === 503;
+      if (isRateLimit && attempt < maxAttempts) {
+        await new Promise((r) => setTimeout(r, delayMs * attempt));
+        continue;
+      }
+      throw error;
+    }
+  }
+  // TypeScript requires a return here, but the loop always returns or throws
+  throw new Error('withRetry: exhausted attempts');
+}
+
+// ---------------------------------------------------------------------------
+// GDocBridge
+// ---------------------------------------------------------------------------
+
+export class GDocBridge {
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+  private _auth: any = null;
+  private _meetingFolderId: string | null = null;
+
+  /** Returns a cached GoogleAuth client with domain-wide delegation. */
+  async getAuth() {
+    if (this._auth) return this._auth;
+
+    const keyContent = await fs.readFile(SERVICE_ACCOUNT_PATH, 'utf-8');
+    const key = JSON.parse(keyContent) as object;
+
+    const auth = new google.auth.GoogleAuth({
+      credentials: key,
+      scopes: [
+        'https://www.googleapis.com/auth/documents',
+        'https://www.googleapis.com/auth/drive',
+      ],
+      clientOptions: {
+        subject: IMPERSONATED_USER,
+      },
+    });
+
+    this._auth = auth;
+    return auth;
+  }
+
+  /**
+   * Returns the ID of the 'Meeting Assistant' folder inside the JARVIS Shared Drive.
+   * Creates the folder if it does not yet exist.
+   */
+  async getMeetingFolderId(): Promise<string> {
+    if (this._meetingFolderId) return this._meetingFolderId;
+
+    const auth = await this.getAuth();
+    const drive = google.drive({ version: 'v3', auth });
+
+    // Search within the Shared Drive for an existing folder
+    const res = await withRetry(() =>
+      drive.files.list({
+        q: `name='${MEETING_FOLDER_NAME}' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
+        driveId: JARVIS_DRIVE_ID,
+        corpora: 'drive',
+        includeItemsFromAllDrives: true,
+        supportsAllDrives: true,
+        fields: 'files(id, name)',
+      }),
+    );
+
+    if (res.data.files && res.data.files.length > 0 && res.data.files[0].id) {
+      this._meetingFolderId = res.data.files[0].id;
+    } else {
+      // Create the folder at the root of the Shared Drive
+      const createRes = await withRetry(() =>
+        drive.files.create({
+          requestBody: {
+            name: MEETING_FOLDER_NAME,
+            mimeType: 'application/vnd.google-apps.folder',
+            parents: [JARVIS_DRIVE_ID],
+          },
+          supportsAllDrives: true,
+          fields: 'id',
+        }),
+      );
+      if (!createRes.data.id) throw new Error('Failed to create Meeting Assistant folder');
+      this._meetingFolderId = createRes.data.id;
+    }
+
+    return this._meetingFolderId!;
+  }
+
+  /**
+   * Creates a new Google Doc in the 'Meeting Assistant' folder.
+   * Optionally writes initial plain-text content.
+   */
+  async createDoc(title: string, content?: string): Promise<{ docId: string; url: string }> {
+    const auth = await this.getAuth();
+    const docs = google.docs({ version: 'v1', auth });
+    const drive = google.drive({ version: 'v3', auth });
+
+    // Create the document (goes to user's My Drive first)
+    const createRes = await withRetry(() =>
+      docs.documents.create({ requestBody: { title } }),
+    );
+    const docId = createRes.data.documentId;
+    if (!docId) throw new Error('Failed to create Google Doc');
+
+    // Move to the Meeting Assistant folder inside the Shared Drive
+    const folderId = await this.getMeetingFolderId();
+    const fileRes = await withRetry(() =>
+      drive.files.get({
+        fileId: docId,
+        fields: 'parents',
+        supportsAllDrives: true,
+      }),
+    );
+    const previousParents = (fileRes.data.parents ?? []).join(',');
+    await withRetry(() =>
+      drive.files.update({
+        fileId: docId,
+        addParents: folderId,
+        removeParents: previousParents,
+        supportsAllDrives: true,
+        fields: 'id, parents',
+      }),
+    );
+
+    // Write initial content if provided
+    if (content) {
+      await this.replaceContent(docId, content);
+    }
+
+    return {
+      docId,
+      url: `https://docs.google.com/document/d/${docId}/edit`,
+    };
+  }
+
+  /**
+   * Reads a Google Doc and returns its body as plain text.
+   */
+  async readDoc(docId: string): Promise<string> {
+    const auth = await this.getAuth();
+    const docs = google.docs({ version: 'v1', auth });
+
+    const res = await withRetry(() =>
+      docs.documents.get({ documentId: docId }),
+    );
+
+    return this.docToPlainText(res.data);
+  }
+
+  /**
+   * Replaces the entire content of a Google Doc with new plain text.
+   */
+  async replaceContent(docId: string, content: string): Promise<void> {
+    const auth = await this.getAuth();
+    const docs = google.docs({ version: 'v1', auth });
+
+    // Get current doc to find end index
+    const currentDoc = await withRetry(() =>
+      docs.documents.get({ documentId: docId }),
+    );
+    const body = currentDoc.data.body;
+    const lastElem = body?.content?.[body.content.length - 1];
+    const endIndex = lastElem?.endIndex ?? 1;
+
+    // Build request list: delete existing body, then insert new content
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    const requests: any[] = [];
+    if (endIndex > 2) {
+      requests.push({
+        deleteContentRange: {
+          range: { startIndex: 1, endIndex: endIndex - 1 },
+        },
+      });
+    }
+    requests.push({
+      insertText: {
+        location: { index: 1 },
+        text: content,
+      },
+    });
+
+    await withRetry(() =>
+      docs.documents.batchUpdate({
+        documentId: docId,
+        requestBody: { requests },
+      }),
+    );
+  }
+
+  // ---------------------------------------------------------------------------
+  // Private helpers
+  // ---------------------------------------------------------------------------
+
+  /** Extracts plain text from a Google Docs API document object. */
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+  private docToPlainText(document: any): string {
+    if (!document?.body?.content) return '';
+    const lines: string[] = [];
+
+    for (const element of document.body.content) {
+      if (!element.paragraph) continue;
+      let text = '';
+      for (const elem of element.paragraph.elements ?? []) {
+        if (elem.textRun?.content) {
+          // The Docs API appends '\n' after each paragraph element — strip it here
+          text += (elem.textRun.content as string).replace(/\n$/, '');
+        }
+      }
+      lines.push(text);
+    }
+
+    return lines.join('\n').trim();
+  }
+}
```

#### `mcp-servers/meeting-assistant/src/index.ts`

```diff
new file mode 100644
index 0000000..8be180e
--- /dev/null
+++ b/mcp-servers/meeting-assistant/src/index.ts
@@ -0,0 +1,402 @@
+#!/usr/bin/env node
+/**
+ * index.ts — Meeting Assistant MCP Server (Phase 1)
+ *
+ * Exposes three MCP tools:
+ *   - start_meeting     Create a Google Doc and start the live-notes update cycle
+ *   - stop_meeting      Halt the update cycle, return full transcript
+ *   - inject_transcript Append a timestamped line to the transcript accumulator
+ *
+ * Phase 1 scope: no audio capture, no STT.  inject_transcript is the only
+ * input mechanism.  Language detection is a placeholder stored in session state.
+ */
+
+import path from 'path';
+import fs from 'fs/promises';
+import { Server } from '@modelcontextprotocol/sdk/server/index.js';
+import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
+import {
+  CallToolRequestSchema,
+  ListToolsRequestSchema,
+} from '@modelcontextprotocol/sdk/types.js';
+import { GDocBridge } from './gdoc-bridge.js';
+import { TranscriptAccumulator } from './transcript.js';
+import { LiveNotesEngine } from './live-notes.js';
+
+// ---------------------------------------------------------------------------
+// Config
+// ---------------------------------------------------------------------------
+
+const ORCHESTRATOR_HOME =
+  process.env.ORCHESTRATOR_HOME ?? path.join(process.env.HOME ?? '/root', 'JARVIS');
+
+const CONFIG_PATH = path.join(ORCHESTRATOR_HOME, 'config', 'meeting-assistant.json');
+const DATA_DIR = path.join(ORCHESTRATOR_HOME, 'data', 'meetings');
+
+interface MeetingConfig {
+  live_notes: {
+    update_interval_ms: number;
+    model: string;
+    google_drive_id: string;
+    folder_name: string;
+  };
+}
+
+async function loadConfig(): Promise<MeetingConfig> {
+  try {
+    const raw = await fs.readFile(CONFIG_PATH, 'utf-8');
+    return JSON.parse(raw) as MeetingConfig;
+  } catch {
+    // Return sensible defaults if config is missing
+    return {
+      live_notes: {
+        update_interval_ms: 30_000,
+        model: 'claude-haiku-4-5-20251001',
+        google_drive_id: '0AC4RjZu6DAzcUk9PVA',
+        folder_name: 'Meeting Assistant',
+      },
+    };
+  }
+}
+
+// ---------------------------------------------------------------------------
+// Session state
+// ---------------------------------------------------------------------------
+
+interface MeetingSession {
+  sessionId: string;
+  docId: string;
+  docUrl: string;
+  title: string;
+  startedAt: string;
+  /** Language detection placeholder — default 'auto'. Future phases populate this. */
+  detected_language: string;
+}
+
+// ---------------------------------------------------------------------------
+// MCP Server
+// ---------------------------------------------------------------------------
+
+class MeetingAssistantServer {
+  private server: Server;
+  private gdoc: GDocBridge;
+  private transcript: TranscriptAccumulator;
+  private liveNotes: LiveNotesEngine;
+  private session: MeetingSession | null = null;
+
+  constructor() {
+    this.server = new Server(
+      { name: 'meeting-assistant', version: '0.1.0' },
+      { capabilities: { tools: {} } },
+    );
+
+    this.gdoc = new GDocBridge();
+    this.transcript = new TranscriptAccumulator();
+    // LiveNotesEngine is configured after loading config in run()
+    this.liveNotes = new LiveNotesEngine(this.gdoc, this.transcript);
+
+    this.setupHandlers();
+
+    this.server.onerror = (error) => console.error('[MCP Error]', error);
+    process.on('SIGINT', async () => {
+      this.liveNotes.stop();
+      await this.server.close();
+      process.exit(0);
+    });
+  }
+
+  // ---------------------------------------------------------------------------
+  // Helper results
+  // ---------------------------------------------------------------------------
+
+  private ok(text: string) {
+    return { content: [{ type: 'text' as const, text }] };
+  }
+
+  private err(message: string) {
+    return { content: [{ type: 'text' as const, text: `Error: ${message}` }], isError: true };
+  }
+
+  // ---------------------------------------------------------------------------
+  // Tool definitions
+  // ---------------------------------------------------------------------------
+
+  private getToolDefinitions() {
+    return [
+      {
+        name: 'start_meeting',
+        description:
+          'Create a new Google Doc in the Meeting Assistant folder and begin the live-notes update cycle. ' +
+          'Returns the session ID, document ID, and document URL.',
+        inputSchema: {
+          type: 'object',
+          properties: {
+            title: {
+              type: 'string',
+              description: 'Meeting title (used as the Google Doc title). Defaults to a timestamped title.',
+            },
+          },
+          required: [],
+        },
+      },
+      {
+        name: 'stop_meeting',
+        description:
+          'Stop the active meeting: halt the live-notes update cycle and return the full transcript.',
+        inputSchema: {
+          type: 'object',
+          properties: {},
+          required: [],
+        },
+      },
+      {
+        name: 'inject_transcript',
+        description:
+          'Append a timestamped line to the transcript accumulator. ' +
+          'This is the primary input mechanism for Phase 1 (no audio capture yet). ' +
+          'A meeting must be active (start_meeting called first).',
+        inputSchema: {
+          type: 'object',
+          properties: {
+            text: {
+              type: 'string',
+              description: 'Spoken text to inject into the transcript.',
+            },
+            speaker: {
+              type: 'string',
+              description: 'Speaker label (e.g. "Pedro", "Guest"). Defaults to "Speaker".',
+            },
+          },
+          required: ['text'],
+        },
+      },
+    ];
+  }
+
+  // ---------------------------------------------------------------------------
+  // Tool implementations
+  // ---------------------------------------------------------------------------
+
+  private async startMeeting(args: { title?: string }): Promise<ReturnType<typeof this.ok>> {
+    if (this.session) {
+      return this.err(
+        `A meeting is already active (session: ${this.session.sessionId}). ` +
+          'Call stop_meeting first.',
+      ) as ReturnType<typeof this.ok>;
+    }
+
+    const now = new Date();
+    const sessionId = `mtg-${now.toISOString().replace(/[:.]/g, '-')}`;
+    const title = args.title?.trim() || `Meeting ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;
+
+    let docId: string;
+    let docUrl: string;
+
+    try {
+      const initialContent = buildInitialDocument(title, now);
+      ({ docId, url: docUrl } = await this.gdoc.createDoc(title, initialContent));
+    } catch (err: unknown) {
+      const msg = err instanceof Error ? err.message : String(err);
+      return this.err(`Failed to create Google Doc: ${msg}`) as ReturnType<typeof this.ok>;
+    }
+
+    // Set up session state
+    this.session = {
+      sessionId,
+      docId,
+      docUrl,
+      title,
+      startedAt: now.toISOString(),
+      detected_language: 'auto', // Phase 1 placeholder
+    };
+
+    // Start transcript accumulator for this session
+    this.transcript.startSession(sessionId);
+
+    // Persist session metadata for later reference
+    await this.persistSessionMeta(this.session).catch((e) =>
+      console.error('[meeting] Could not persist session meta:', e),
+    );
+
+    // Start the live-notes update cycle
+    this.liveNotes.start(docId);
+
+    return this.ok(
+      JSON.stringify(
+        {
+          sessionId,
+          docId,
+          docUrl,
+          title,
+          startedAt: now.toISOString(),
+          detected_language: 'auto',
+          message: 'Meeting started. Use inject_transcript to add transcript lines.',
+        },
+        null,
+        2,
+      ),
+    );
+  }
+
+  private async stopMeeting(): Promise<ReturnType<typeof this.ok>> {
+    if (!this.session) {
+      return this.err('No active meeting. Call start_meeting first.') as ReturnType<
+        typeof this.ok
+      >;
+    }
+
+    this.liveNotes.stop();
+
+    const fullTranscript = this.transcript.format();
+    const session = this.session;
+    const endedAt = new Date().toISOString();
+
+    this.session = null;
+    this.transcript.endSession();
+    this.transcript.clear();
+
+    return this.ok(
+      JSON.stringify(
+        {
+          sessionId: session.sessionId,
+          docId: session.docId,
+          docUrl: session.docUrl,
+          title: session.title,
+          startedAt: session.startedAt,
+          endedAt,
+          transcript: fullTranscript,
+          message: 'Meeting stopped. See docUrl for live notes.',
+        },
+        null,
+        2,
+      ),
+    );
+  }
+
+  private injectTranscript(args: { text: string; speaker?: string }): ReturnType<typeof this.ok> {
+    if (!this.session) {
+      return this.err('No active meeting. Call start_meeting first.') as ReturnType<typeof this.ok>;
+    }
+
+    const speaker = args.speaker?.trim() || 'Speaker';
+    const line = this.transcript.append(speaker, args.text);
+
+    return this.ok(
+      JSON.stringify(
+        {
+          ok: true,
+          line,
+          totalLines: this.transcript.getCount(),
+        },
+        null,
+        2,
+      ),
+    );
+  }
+
+  // ---------------------------------------------------------------------------
+  // Persistence helpers
+  // ---------------------------------------------------------------------------
+
+  private async persistSessionMeta(session: MeetingSession): Promise<void> {
+    const dir = path.join(DATA_DIR, session.startedAt.slice(0, 10));
+    await fs.mkdir(dir, { recursive: true });
+    const metaPath = path.join(dir, `${session.sessionId}.meta.json`);
+    await fs.writeFile(metaPath, JSON.stringify(session, null, 2), 'utf-8');
+  }
+
+  // ---------------------------------------------------------------------------
+  // Handler setup
+  // ---------------------------------------------------------------------------
+
+  private setupHandlers(): void {
+    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
+      tools: this.getToolDefinitions(),
+    }));
+
+    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
+      const { name, arguments: args } = request.params;
+
+      try {
+        switch (name) {
+          case 'start_meeting':
+            return await this.startMeeting((args ?? {}) as { title?: string });
+          case 'stop_meeting':
+            return await this.stopMeeting();
+          case 'inject_transcript':
+            return this.injectTranscript(
+              (args ?? {}) as { text: string; speaker?: string },
+            );
+          default:
+            throw new Error(`Unknown tool: ${name}`);
+        }
+      } catch (error: unknown) {
+        const msg = error instanceof Error ? error.message : String(error);
+        return this.err(msg);
+      }
+    });
+  }
+
+  // ---------------------------------------------------------------------------
+  // Entry point
+  // ---------------------------------------------------------------------------
+
+  async run(): Promise<void> {
+    const config = await loadConfig();
+
+    // Re-create LiveNotesEngine with config values
+    this.liveNotes = new LiveNotesEngine(this.gdoc, this.transcript, {
+      updateIntervalMs: config.live_notes.update_interval_ms,
+      claudeModel: config.live_notes.model,
+    });
+
+    const transport = new StdioServerTransport();
+    await this.server.connect(transport);
+    console.error('Meeting Assistant MCP server running on stdio');
+  }
+}
+
+// ---------------------------------------------------------------------------
+// Initial document template
+// ---------------------------------------------------------------------------
+
+function buildInitialDocument(title: string, startedAt: Date): string {
+  const dateStr = startedAt.toLocaleDateString('en-US', {
+    weekday: 'long',
+    year: 'numeric',
+    month: 'long',
+    day: 'numeric',
+  });
+  const timeStr = startedAt.toLocaleTimeString('en-US', {
+    hour: '2-digit',
+    minute: '2-digit',
+  });
+
+  return `# ${title}
+
+**Date:** ${dateStr}
+**Start time:** ${timeStr}
+**Status:** In progress
+
+---
+
+## Summary
+
+*(Will be updated automatically as the meeting progresses)*
+
+## Discussion Points
+
+## Decisions
+
+## Action Items
+
+## Notes
+`;
+}
+
+// ---------------------------------------------------------------------------
+// Bootstrap
+// ---------------------------------------------------------------------------
+
+const server = new MeetingAssistantServer();
+server.run().catch(console.error);
```

#### `mcp-servers/meeting-assistant/src/live-notes.ts`

```diff
new file mode 100644
index 0000000..14aff78
--- /dev/null
+++ b/mcp-servers/meeting-assistant/src/live-notes.ts
@@ -0,0 +1,190 @@
+/**
+ * live-notes.ts
+ *
+ * Live Notes Update Engine for the Meeting Assistant.
+ *
+ * Every ~30 seconds (configurable):
+ *  1. Reads all new transcript lines since the last cycle
+ *  2. Reads the current Google Doc content
+ *  3. Calls `claude --print` (piped via stdin) to generate updated notes
+ *  4. Writes the result back to the Google Doc
+ *
+ * Audio capture and STT are out of scope for Phase 1 — transcript lines
+ * are injected manually via the inject_transcript MCP tool.
+ */
+
+import { spawnSync } from 'child_process';
+import type { GDocBridge } from './gdoc-bridge.js';
+import type { TranscriptAccumulator } from './transcript.js';
+
+const DEFAULT_UPDATE_INTERVAL_MS = 30_000;
+const DEFAULT_CLAUDE_MODEL = 'claude-haiku-4-5-20251001';
+
+export interface LiveNotesConfig {
+  updateIntervalMs?: number;
+  claudeModel?: string;
+}
+
+export class LiveNotesEngine {
+  private timer: NodeJS.Timeout | null = null;
+  private lastProcessedIndex = 0;
+  private docId: string | null = null;
+  private readonly intervalMs: number;
+  private readonly model: string;
+
+  constructor(
+    private readonly gdoc: GDocBridge,
+    private readonly transcript: TranscriptAccumulator,
+    config: LiveNotesConfig = {},
+  ) {
+    this.intervalMs = config.updateIntervalMs ?? DEFAULT_UPDATE_INTERVAL_MS;
+    this.model = config.claudeModel ?? DEFAULT_CLAUDE_MODEL;
+  }
+
+  // ---------------------------------------------------------------------------
+  // Lifecycle
+  // ---------------------------------------------------------------------------
+
+  /** Begin the periodic update cycle for the given document. */
+  start(docId: string): void {
+    if (this.timer) {
+      clearInterval(this.timer);
+    }
+    this.docId = docId;
+    this.lastProcessedIndex = 0;
+    this.timer = setInterval(() => {
+      this.runUpdateCycle().catch((err) =>
+        console.error('[live-notes] Unhandled update error:', err),
+      );
+    }, this.intervalMs);
+    console.error(`[live-notes] Started. Updating every ${this.intervalMs}ms. Doc: ${docId}`);
+  }
+
+  /** Stop the periodic update cycle. */
+  stop(): void {
+    if (this.timer) {
+      clearInterval(this.timer);
+      this.timer = null;
+    }
+    this.docId = null;
+    console.error('[live-notes] Stopped.');
+  }
+
+  /** Returns true if the update cycle is currently running. */
+  isRunning(): boolean {
+    return this.timer !== null;
+  }
+
+  // ---------------------------------------------------------------------------
+  // Update cycle
+  // ---------------------------------------------------------------------------
+
+  /**
+   * Single update pass:
+   *  - Fetch new transcript lines since last cycle
+   *  - Read current doc
+   *  - Ask Claude to merge notes
+   *  - Write back to doc
+   */
+  async runUpdateCycle(): Promise<void> {
+    if (!this.docId) return;
+
+    const newLines = this.transcript.getSince(this.lastProcessedIndex);
+    if (newLines.length === 0) {
+      // Nothing new — skip this cycle
+      return;
+    }
+
+    const newLineCount = newLines.length;
+    this.lastProcessedIndex = this.transcript.getCount();
+
+    let currentContent: string;
+    try {
+      currentContent = await this.gdoc.readDoc(this.docId);
+    } catch (err) {
+      console.error('[live-notes] Failed to read doc:', err);
+      return;
+    }
+
+    const newTranscript = this.transcript.format(newLines);
+
+    const prompt = buildPrompt(currentContent, newTranscript);
+
+    const updatedContent = this.callClaude(prompt);
+    if (!updatedContent) {
+      console.error('[live-notes] Claude returned empty output — skipping write.');
+      return;
+    }
+
+    try {
+      await this.gdoc.replaceContent(this.docId, updatedContent);
+      console.error(
+        `[live-notes] Notes updated. Processed ${newLineCount} new transcript line(s).`,
+      );
+    } catch (err) {
+      console.error('[live-notes] Failed to write updated notes to doc:', err);
+    }
+  }
+
+  // ---------------------------------------------------------------------------
+  // Claude integration
+  // ---------------------------------------------------------------------------
+
+  /**
+   * Calls `claude --print` with the given prompt via stdin.
+   *
+   * Per JARVIS lessons learned:
+   *  - Pipe prompt via stdin (never pass as CLI argument) to avoid shell escaping issues
+   *  - claude --print inside loops consumes stdin; using spawnSync with `input` avoids this
+   */
+  private callClaude(prompt: string): string {
+    const result = spawnSync('claude', ['--print', '--model', this.model], {
+      input: prompt,
+      encoding: 'utf-8',
+      timeout: 60_000,
+      maxBuffer: 10 * 1024 * 1024,
+    });
+
+    if (result.error) {
+      console.error('[live-notes] claude spawn error:', result.error.message);
+      return '';
+    }
+    if (result.status !== 0) {
+      console.error(
+        '[live-notes] claude exited with status',
+        result.status,
+        result.stderr ?? '',
+      );
+      return '';
+    }
+
+    return (result.stdout ?? '').trim();
+  }
+}
+
+// ---------------------------------------------------------------------------
+// Prompt builder
+// ---------------------------------------------------------------------------
+
+function buildPrompt(currentNotes: string, newTranscript: string): string {
+  const hasNotes = currentNotes.trim().length > 0;
+
+  if (!hasNotes) {
+    return `You are a meeting assistant. The following is a transcript excerpt from an ongoing meeting. Create structured meeting notes in markdown format based on this transcript.
+
+TRANSCRIPT:
+${newTranscript}
+
+Return ONLY the meeting notes in markdown, no preamble. Use sections: Summary, Discussion Points, Decisions, Action Items.`;
+  }
+
+  return `You are a meeting assistant. Update the following meeting notes by integrating new transcript lines. Preserve all existing content and structure.
+
+CURRENT NOTES:
+${currentNotes}
+
+NEW TRANSCRIPT LINES:
+${newTranscript}
+
+Return ONLY the complete updated meeting notes in markdown format, no preamble or explanation.`;
+}
```

#### `mcp-servers/meeting-assistant/src/transcript.ts`

```diff
new file mode 100644
index 0000000..97e2b6b
--- /dev/null
+++ b/mcp-servers/meeting-assistant/src/transcript.ts
@@ -0,0 +1,97 @@
+/**
+ * transcript.ts
+ *
+ * Transcript accumulator for the Meeting Assistant.
+ * Stores timestamped lines with speaker labels in memory.
+ * In Phase 1, lines are injected via the inject_transcript MCP tool.
+ * Future phases will feed lines from STT providers.
+ */
+
+export interface TranscriptLine {
+  timestamp: string; // ISO 8601
+  speaker: string;
+  text: string;
+}
+
+export class TranscriptAccumulator {
+  private lines: TranscriptLine[] = [];
+  private sessionId: string | null = null;
+
+  // ---------------------------------------------------------------------------
+  // Session lifecycle
+  // ---------------------------------------------------------------------------
+
+  /** Start a new session, clearing any previous transcript. */
+  startSession(sessionId: string): void {
+    this.sessionId = sessionId;
+    this.lines = [];
+  }
+
+  /** Clear the active session reference (does not erase transcript lines). */
+  endSession(): void {
+    this.sessionId = null;
+  }
+
+  // ---------------------------------------------------------------------------
+  // Core operations
+  // ---------------------------------------------------------------------------
+
+  /**
+   * Append a new line to the transcript.
+   * @param speaker  Speaker label (e.g. "Pedro", "Speaker 1")
+   * @param text     Spoken text
+   * @returns The newly created TranscriptLine
+   */
+  append(speaker: string, text: string): TranscriptLine {
+    const line: TranscriptLine = {
+      timestamp: new Date().toISOString(),
+      speaker: speaker.trim() || 'Unknown',
+      text: text.trim(),
+    };
+    this.lines.push(line);
+    return line;
+  }
+
+  /** Return a copy of all lines. */
+  getAll(): TranscriptLine[] {
+    return [...this.lines];
+  }
+
+  /**
+   * Return lines starting at the given index (0-based, inclusive).
+   * Useful for the live-notes engine to fetch only new lines since the last update.
+   */
+  getSince(fromIndex: number): TranscriptLine[] {
+    return this.lines.slice(fromIndex);
+  }
+
+  /** Total number of lines accumulated so far. */
+  getCount(): number {
+    return this.lines.length;
+  }
+
+  /** Current session ID, or null if no session is active. */
+  getSessionId(): string | null {
+    return this.sessionId;
+  }
+
+  // ---------------------------------------------------------------------------
+  // Formatting helpers
+  // ---------------------------------------------------------------------------
+
+  /**
+   * Format a set of transcript lines (or all lines) as a human-readable string.
+   * Format: [ISO timestamp] Speaker: text
+   */
+  format(lines?: TranscriptLine[]): string {
+    const target = lines ?? this.lines;
+    return target
+      .map((l) => `[${l.timestamp}] ${l.speaker}: ${l.text}`)
+      .join('\n');
+  }
+
+  /** Reset all accumulated lines (e.g. after stop_meeting). */
+  clear(): void {
+    this.lines = [];
+  }
+}
```

#### `mcp-servers/meeting-assistant/tsconfig.json`

```diff
new file mode 100644
index 0000000..be93011
--- /dev/null
+++ b/mcp-servers/meeting-assistant/tsconfig.json
@@ -0,0 +1,15 @@
+{
+  "compilerOptions": {
+    "target": "ES2022",
+    "module": "Node16",
+    "moduleResolution": "Node16",
+    "strict": true,
+    "esModuleInterop": true,
+    "skipLibCheck": true,
+    "outDir": "dist",
+    "rootDir": "src",
+    "declaration": true
+  },
+  "include": ["src/**/*.ts"],
+  "exclude": ["node_modules", "dist"]
+}
```

---

## Apply Instructions

Patches at: `/tmp/jarvis-sandbox-20260222-102048-VQ7JO/`

```bash
# Apply
cd /home/teruel/JARVIS && git am /tmp/jarvis-sandbox-20260222-102048-VQ7JO/*.patch

# Discard
rm -rf /tmp/jarvis-sandbox-20260222-102048-VQ7JO
```
